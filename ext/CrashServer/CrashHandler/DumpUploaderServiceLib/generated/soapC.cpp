/* soapC.cpp
   Generated by gSOAP 2.8.0 from DumpUploader.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   The generated code is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.0 2012-01-09 21:40:51 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
    if (soap->header)
        soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
    if (soap->header)
    {   soap->part = SOAP_IN_HEADER;
        if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
            return soap->error;
        soap->part = SOAP_END_HEADER;
    }
    return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
    soap->part = SOAP_IN_HEADER;
    soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
    soap->part = SOAP_END_HEADER;
    return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
    if (!soap->header)
    {   if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
            soap_default_SOAP_ENV__Header(soap, soap->header);
    }
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
    if (!soap->fault)
    {   soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
        if (!soap->fault)
            return;
        soap_default_SOAP_ENV__Fault(soap, soap->fault);
    }
    if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
    {   soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
        soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
    }
    if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
    {   soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
        soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
    }
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
    soap_fault(soap);
    if (soap->fault)
        soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
    if (soap->fault)
        return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
    return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
    return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
    soap_fault(soap);
    if (soap->version == 2)
        return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
    return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
    soap_fault(soap);
    if (soap->version == 2)
    {   if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
        {   soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
            soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
        }
        return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
    }
    return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
    soap_fault(soap);
    if (soap->version == 2)
        return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
    return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
    soap_fault(soap);
    if (soap->version == 1)
    {   if (!soap->fault->detail)
        {   soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
            soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
        }
        return (const char**)&soap->fault->detail->__any;
    }
    if (!soap->fault->SOAP_ENV__Detail)
    {   soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
        soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
    }
    return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
    int t;
    if (soap->version == 1)
    {   for (;;)
        {   if (!soap_getelement(soap, &t))
                if (soap->error || soap_ignore_element(soap))
                    break;
        }
    }
    if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
        soap->error = SOAP_OK;
    return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
    if (soap_peek_element(soap))
        return NULL;
    if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
        *type = soap_lookup_type(soap, soap->href);
    switch (*type)
    {
    case SOAP_TYPE_byte:
        return soap_in_byte(soap, NULL, NULL, "xsd:byte");
    case SOAP_TYPE_short:
        return soap_in_short(soap, NULL, NULL, "xsd:short");
    case SOAP_TYPE_int:
        return soap_in_int(soap, NULL, NULL, "xsd:int");
    case SOAP_TYPE_unsignedByte:
        return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
    case SOAP_TYPE_unsignedShort:
        return soap_in_unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
    case SOAP_TYPE_unsignedInt:
        return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
    case SOAP_TYPE_bool:
        return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
    case SOAP_TYPE_ns1__AdditionalInfoType:
        return soap_in_ns1__AdditionalInfoType(soap, NULL, NULL, "ns1:AdditionalInfoType");
    case SOAP_TYPE_ns1__SolutionType:
        return soap_in_ns1__SolutionType(soap, NULL, NULL, "ns1:SolutionType");
    case SOAP_TYPE_ns1__ResponseType:
        return soap_in_ns1__ResponseType(soap, NULL, NULL, "ns1:ResponseType");
    case SOAP_TYPE_ns1__Architecture:
        return soap_in_ns1__Architecture(soap, NULL, NULL, "ns1:Architecture");
    case SOAP_TYPE_ns2__guid:
        return soap_in_ns2__guid(soap, NULL, NULL, "ns2:guid");
    case SOAP_TYPE_std__wstring:
        return soap_in_std__wstring(soap, NULL, NULL, "xsd:string");
    case SOAP_TYPE_ns1__Solution:
        return soap_in_ns1__Solution(soap, NULL, NULL, "ns1:Solution");
    case SOAP_TYPE_ns1__Response:
        return soap_in_ns1__Response(soap, NULL, NULL, "ns1:Response");
    case SOAP_TYPE_ns1__Application:
        return soap_in_ns1__Application(soap, NULL, NULL, "ns1:Application");
    case SOAP_TYPE_ns1__ClientLib:
        return soap_in_ns1__ClientLib(soap, NULL, NULL, "ns1:ClientLib");
    case SOAP_TYPE_PointerTo_ns1__UploadSymbolResponse:
        return soap_in_PointerTo_ns1__UploadSymbolResponse(soap, NULL, NULL, "ns1:UploadSymbolResponse");
    case SOAP_TYPE_PointerTo_ns1__UploadSymbol:
        return soap_in_PointerTo_ns1__UploadSymbol(soap, NULL, NULL, "ns1:UploadSymbol");
    case SOAP_TYPE_PointerTo_ns1__UploadAdditionalInfoResponse:
        return soap_in_PointerTo_ns1__UploadAdditionalInfoResponse(soap, NULL, NULL, "ns1:UploadAdditionalInfoResponse");
    case SOAP_TYPE_PointerTo_ns1__UploadAdditionalInfo:
        return soap_in_PointerTo_ns1__UploadAdditionalInfo(soap, NULL, NULL, "ns1:UploadAdditionalInfo");
    case SOAP_TYPE_PointerTo_ns1__UploadMiniDumpResponse:
        return soap_in_PointerTo_ns1__UploadMiniDumpResponse(soap, NULL, NULL, "ns1:UploadMiniDumpResponse");
    case SOAP_TYPE_PointerTo_ns1__UploadMiniDump:
        return soap_in_PointerTo_ns1__UploadMiniDump(soap, NULL, NULL, "ns1:UploadMiniDump");
    case SOAP_TYPE_PointerTo_ns1__HelloResponse:
        return soap_in_PointerTo_ns1__HelloResponse(soap, NULL, NULL, "ns1:HelloResponse");
    case SOAP_TYPE_PointerTo_ns1__Hello:
        return soap_in_PointerTo_ns1__Hello(soap, NULL, NULL, "ns1:Hello");
    case SOAP_TYPE_PointerTons1__Response:
        return soap_in_PointerTons1__Response(soap, NULL, NULL, "ns1:Response");
    case SOAP_TYPE_PointerTons1__Application:
        return soap_in_PointerTons1__Application(soap, NULL, NULL, "ns1:Application");
    case SOAP_TYPE_PointerTons1__ClientLib:
        return soap_in_PointerTons1__ClientLib(soap, NULL, NULL, "ns1:ClientLib");
    case SOAP_TYPE_PointerTo_xop__Include:
        return soap_in_PointerTo_xop__Include(soap, NULL, NULL, "xop:Include");
    case SOAP_TYPE_PointerTons1__Solution:
        return soap_in_PointerTons1__Solution(soap, NULL, NULL, "ns1:Solution");
    case SOAP_TYPE_PointerTostd__wstring:
        return soap_in_PointerTostd__wstring(soap, NULL, NULL, "xsd:string");
    case SOAP_TYPE_PointerTounsignedByte:
        return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
    case SOAP_TYPE__QName:
    {   char **s;
        s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
        return s ? *s : NULL;
    }
    case SOAP_TYPE_string:
    {   char **s;
        s = soap_in_string(soap, NULL, NULL, "xsd:string");
        return s ? *s : NULL;
    }
    default:
    {   const char *t = soap->type;
        if (!*t)
            t = soap->tag;
        if (!soap_match_tag(soap, t, "ns2:guid"))
        {   *type = SOAP_TYPE_ns2__guid;
            return soap_in_ns2__guid(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "xsd:string"))
        {   *type = SOAP_TYPE_std__wstring;
            return soap_in_std__wstring(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "ns1:Solution"))
        {   *type = SOAP_TYPE_ns1__Solution;
            return soap_in_ns1__Solution(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "ns1:Response"))
        {   *type = SOAP_TYPE_ns1__Response;
            return soap_in_ns1__Response(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "ns1:Application"))
        {   *type = SOAP_TYPE_ns1__Application;
            return soap_in_ns1__Application(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "ns1:ClientLib"))
        {   *type = SOAP_TYPE_ns1__ClientLib;
            return soap_in_ns1__ClientLib(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "xsd:byte"))
        {   *type = SOAP_TYPE_byte;
            return soap_in_byte(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "xsd:short"))
        {   *type = SOAP_TYPE_short;
            return soap_in_short(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "xsd:int"))
        {   *type = SOAP_TYPE_int;
            return soap_in_int(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
        {   *type = SOAP_TYPE_unsignedByte;
            return soap_in_unsignedByte(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
        {   *type = SOAP_TYPE_unsignedShort;
            return soap_in_unsignedShort(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
        {   *type = SOAP_TYPE_unsignedInt;
            return soap_in_unsignedInt(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "xsd:boolean"))
        {   *type = SOAP_TYPE_bool;
            return soap_in_bool(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "ns1:AdditionalInfoType"))
        {   *type = SOAP_TYPE_ns1__AdditionalInfoType;
            return soap_in_ns1__AdditionalInfoType(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "ns1:SolutionType"))
        {   *type = SOAP_TYPE_ns1__SolutionType;
            return soap_in_ns1__SolutionType(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "ns1:ResponseType"))
        {   *type = SOAP_TYPE_ns1__ResponseType;
            return soap_in_ns1__ResponseType(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "ns1:Architecture"))
        {   *type = SOAP_TYPE_ns1__Architecture;
            return soap_in_ns1__Architecture(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "xsd:QName"))
        {   char **s;
            *type = SOAP_TYPE__QName;
            s = soap_in__QName(soap, NULL, NULL, NULL);
            return s ? *s : NULL;
        }
        if (!soap_match_tag(soap, t, "xsd:string"))
        {   char **s;
            *type = SOAP_TYPE_string;
            s = soap_in_string(soap, NULL, NULL, NULL);
            return s ? *s : NULL;
        }
        t = soap->tag;
        if (!soap_match_tag(soap, t, "ns1:UploadSymbolResponse"))
        {   *type = SOAP_TYPE__ns1__UploadSymbolResponse;
            return soap_in__ns1__UploadSymbolResponse(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "ns1:UploadSymbol"))
        {   *type = SOAP_TYPE__ns1__UploadSymbol;
            return soap_in__ns1__UploadSymbol(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "ns1:UploadAdditionalInfoResponse"))
        {   *type = SOAP_TYPE__ns1__UploadAdditionalInfoResponse;
            return soap_in__ns1__UploadAdditionalInfoResponse(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "ns1:UploadAdditionalInfo"))
        {   *type = SOAP_TYPE__ns1__UploadAdditionalInfo;
            return soap_in__ns1__UploadAdditionalInfo(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "ns1:UploadMiniDumpResponse"))
        {   *type = SOAP_TYPE__ns1__UploadMiniDumpResponse;
            return soap_in__ns1__UploadMiniDumpResponse(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "ns1:UploadMiniDump"))
        {   *type = SOAP_TYPE__ns1__UploadMiniDump;
            return soap_in__ns1__UploadMiniDump(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "ns1:HelloResponse"))
        {   *type = SOAP_TYPE__ns1__HelloResponse;
            return soap_in__ns1__HelloResponse(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "ns1:Hello"))
        {   *type = SOAP_TYPE__ns1__Hello;
            return soap_in__ns1__Hello(soap, NULL, NULL, NULL);
        }
        if (!soap_match_tag(soap, t, "xop:Include"))
        {   *type = SOAP_TYPE__xop__Include;
            return soap_in__xop__Include(soap, NULL, NULL, NULL);
        }
    }
    }
    soap->error = SOAP_TAG_MISMATCH;
    return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
    if (!soap_peek_element(soap))
    {   int t;
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
        if (soap->mustUnderstand && !soap->other)
            return soap->error = SOAP_MUSTUNDERSTAND;
        if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
        {   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
            return soap->error = SOAP_TAG_MISMATCH;
        }
        if (!*soap->id || !soap_getelement(soap, &t))
        {   soap->peeked = 0;
            if (soap->fignore)
                soap->error = soap->fignore(soap, soap->tag);
            else
                soap->error = SOAP_OK;
            DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
            if (!soap->error && soap->body)
            {   soap->level++;
                while (!soap_ignore_element(soap))
                    ;
                if (soap->error == SOAP_NO_TAG)
                    soap->error = soap_element_end_in(soap, NULL);
            }
        }
    }
    return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
    int i;
    struct soap_plist *pp;
    if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
        for (i = 0; i < SOAP_PTRHASH; i++)
            for (pp = soap->pht[i]; pp; pp = pp->next)
                if (pp->mark1 == 2 || pp->mark2 == 2)
                    if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
                        return soap->error;
    return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
    switch (type)
    {
    case SOAP_TYPE_byte:
        return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
    case SOAP_TYPE_short:
        return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
    case SOAP_TYPE_int:
        return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
    case SOAP_TYPE_unsignedByte:
        return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
    case SOAP_TYPE_unsignedShort:
        return soap_out_unsignedShort(soap, tag, id, (const unsigned short *)ptr, "xsd:unsignedShort");
    case SOAP_TYPE_unsignedInt:
        return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
    case SOAP_TYPE_bool:
        return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
    case SOAP_TYPE_ns1__AdditionalInfoType:
        return soap_out_ns1__AdditionalInfoType(soap, tag, id, (const enum ns1__AdditionalInfoType *)ptr, "ns1:AdditionalInfoType");
    case SOAP_TYPE_ns1__SolutionType:
        return soap_out_ns1__SolutionType(soap, tag, id, (const enum ns1__SolutionType *)ptr, "ns1:SolutionType");
    case SOAP_TYPE_ns1__ResponseType:
        return soap_out_ns1__ResponseType(soap, tag, id, (const enum ns1__ResponseType *)ptr, "ns1:ResponseType");
    case SOAP_TYPE_ns1__Architecture:
        return soap_out_ns1__Architecture(soap, tag, id, (const enum ns1__Architecture *)ptr, "ns1:Architecture");
    case SOAP_TYPE_ns2__guid:
        return soap_out_ns2__guid(soap, tag, id, (const std::wstring *)ptr, "ns2:guid");
    case SOAP_TYPE_std__wstring:
        return soap_out_std__wstring(soap, tag, id, (const std::wstring *)ptr, "xsd:string");
    case SOAP_TYPE__ns1__UploadSymbolResponse:
        return ((_ns1__UploadSymbolResponse *)ptr)->soap_out(soap, "ns1:UploadSymbolResponse", id, NULL);
    case SOAP_TYPE__ns1__UploadSymbol:
        return ((_ns1__UploadSymbol *)ptr)->soap_out(soap, "ns1:UploadSymbol", id, NULL);
    case SOAP_TYPE__ns1__UploadAdditionalInfoResponse:
        return ((_ns1__UploadAdditionalInfoResponse *)ptr)->soap_out(soap, "ns1:UploadAdditionalInfoResponse", id, NULL);
    case SOAP_TYPE__ns1__UploadAdditionalInfo:
        return ((_ns1__UploadAdditionalInfo *)ptr)->soap_out(soap, "ns1:UploadAdditionalInfo", id, NULL);
    case SOAP_TYPE__ns1__UploadMiniDumpResponse:
        return ((_ns1__UploadMiniDumpResponse *)ptr)->soap_out(soap, "ns1:UploadMiniDumpResponse", id, NULL);
    case SOAP_TYPE__ns1__UploadMiniDump:
        return ((_ns1__UploadMiniDump *)ptr)->soap_out(soap, "ns1:UploadMiniDump", id, NULL);
    case SOAP_TYPE__ns1__HelloResponse:
        return ((_ns1__HelloResponse *)ptr)->soap_out(soap, "ns1:HelloResponse", id, NULL);
    case SOAP_TYPE__ns1__Hello:
        return ((_ns1__Hello *)ptr)->soap_out(soap, "ns1:Hello", id, NULL);
    case SOAP_TYPE_ns1__Solution:
        return ((ns1__Solution *)ptr)->soap_out(soap, tag, id, "ns1:Solution");
    case SOAP_TYPE_ns1__Response:
        return ((ns1__Response *)ptr)->soap_out(soap, tag, id, "ns1:Response");
    case SOAP_TYPE_ns1__Application:
        return ((ns1__Application *)ptr)->soap_out(soap, tag, id, "ns1:Application");
    case SOAP_TYPE_ns1__ClientLib:
        return ((ns1__ClientLib *)ptr)->soap_out(soap, tag, id, "ns1:ClientLib");
    case SOAP_TYPE__xop__Include:
        return soap_out__xop__Include(soap, "xop:Include", id, (const struct _xop__Include *)ptr, NULL);
    case SOAP_TYPE_PointerTo_ns1__UploadSymbolResponse:
        return soap_out_PointerTo_ns1__UploadSymbolResponse(soap, tag, id, (_ns1__UploadSymbolResponse *const*)ptr, "ns1:UploadSymbolResponse");
    case SOAP_TYPE_PointerTo_ns1__UploadSymbol:
        return soap_out_PointerTo_ns1__UploadSymbol(soap, tag, id, (_ns1__UploadSymbol *const*)ptr, "ns1:UploadSymbol");
    case SOAP_TYPE_PointerTo_ns1__UploadAdditionalInfoResponse:
        return soap_out_PointerTo_ns1__UploadAdditionalInfoResponse(soap, tag, id, (_ns1__UploadAdditionalInfoResponse *const*)ptr, "ns1:UploadAdditionalInfoResponse");
    case SOAP_TYPE_PointerTo_ns1__UploadAdditionalInfo:
        return soap_out_PointerTo_ns1__UploadAdditionalInfo(soap, tag, id, (_ns1__UploadAdditionalInfo *const*)ptr, "ns1:UploadAdditionalInfo");
    case SOAP_TYPE_PointerTo_ns1__UploadMiniDumpResponse:
        return soap_out_PointerTo_ns1__UploadMiniDumpResponse(soap, tag, id, (_ns1__UploadMiniDumpResponse *const*)ptr, "ns1:UploadMiniDumpResponse");
    case SOAP_TYPE_PointerTo_ns1__UploadMiniDump:
        return soap_out_PointerTo_ns1__UploadMiniDump(soap, tag, id, (_ns1__UploadMiniDump *const*)ptr, "ns1:UploadMiniDump");
    case SOAP_TYPE_PointerTo_ns1__HelloResponse:
        return soap_out_PointerTo_ns1__HelloResponse(soap, tag, id, (_ns1__HelloResponse *const*)ptr, "ns1:HelloResponse");
    case SOAP_TYPE_PointerTo_ns1__Hello:
        return soap_out_PointerTo_ns1__Hello(soap, tag, id, (_ns1__Hello *const*)ptr, "ns1:Hello");
    case SOAP_TYPE_PointerTons1__Response:
        return soap_out_PointerTons1__Response(soap, tag, id, (ns1__Response *const*)ptr, "ns1:Response");
    case SOAP_TYPE_PointerTons1__Application:
        return soap_out_PointerTons1__Application(soap, tag, id, (ns1__Application *const*)ptr, "ns1:Application");
    case SOAP_TYPE_PointerTons1__ClientLib:
        return soap_out_PointerTons1__ClientLib(soap, tag, id, (ns1__ClientLib *const*)ptr, "ns1:ClientLib");
    case SOAP_TYPE_PointerTo_xop__Include:
        return soap_out_PointerTo_xop__Include(soap, tag, id, (struct _xop__Include *const*)ptr, "xop:Include");
    case SOAP_TYPE_PointerTons1__Solution:
        return soap_out_PointerTons1__Solution(soap, tag, id, (ns1__Solution *const*)ptr, "ns1:Solution");
    case SOAP_TYPE_PointerTostd__wstring:
        return soap_out_PointerTostd__wstring(soap, tag, id, (std::wstring *const*)ptr, "xsd:string");
    case SOAP_TYPE_PointerTounsignedByte:
        return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
    case SOAP_TYPE__QName:
        return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
    case SOAP_TYPE_string:
        return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
    }
    return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
    (void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
    switch (type)
    {
    case SOAP_TYPE_ns2__guid:
        soap_serialize_ns2__guid(soap, (const std::wstring *)ptr);
        break;
    case SOAP_TYPE_std__wstring:
        soap_serialize_std__wstring(soap, (const std::wstring *)ptr);
        break;
    case SOAP_TYPE__ns1__UploadSymbolResponse:
        ((_ns1__UploadSymbolResponse *)ptr)->soap_serialize(soap);
        break;
    case SOAP_TYPE__ns1__UploadSymbol:
        ((_ns1__UploadSymbol *)ptr)->soap_serialize(soap);
        break;
    case SOAP_TYPE__ns1__UploadAdditionalInfoResponse:
        ((_ns1__UploadAdditionalInfoResponse *)ptr)->soap_serialize(soap);
        break;
    case SOAP_TYPE__ns1__UploadAdditionalInfo:
        ((_ns1__UploadAdditionalInfo *)ptr)->soap_serialize(soap);
        break;
    case SOAP_TYPE__ns1__UploadMiniDumpResponse:
        ((_ns1__UploadMiniDumpResponse *)ptr)->soap_serialize(soap);
        break;
    case SOAP_TYPE__ns1__UploadMiniDump:
        ((_ns1__UploadMiniDump *)ptr)->soap_serialize(soap);
        break;
    case SOAP_TYPE__ns1__HelloResponse:
        ((_ns1__HelloResponse *)ptr)->soap_serialize(soap);
        break;
    case SOAP_TYPE__ns1__Hello:
        ((_ns1__Hello *)ptr)->soap_serialize(soap);
        break;
    case SOAP_TYPE_ns1__Solution:
        ((ns1__Solution *)ptr)->soap_serialize(soap);
        break;
    case SOAP_TYPE_ns1__Response:
        ((ns1__Response *)ptr)->soap_serialize(soap);
        break;
    case SOAP_TYPE_ns1__Application:
        ((ns1__Application *)ptr)->soap_serialize(soap);
        break;
    case SOAP_TYPE_ns1__ClientLib:
        ((ns1__ClientLib *)ptr)->soap_serialize(soap);
        break;
    case SOAP_TYPE___ns4__UploadSymbol:
        soap_serialize___ns4__UploadSymbol(soap, (const struct __ns4__UploadSymbol *)ptr);
        break;
    case SOAP_TYPE___ns4__UploadAdditionalInfo:
        soap_serialize___ns4__UploadAdditionalInfo(soap, (const struct __ns4__UploadAdditionalInfo *)ptr);
        break;
    case SOAP_TYPE___ns4__UploadMiniDump:
        soap_serialize___ns4__UploadMiniDump(soap, (const struct __ns4__UploadMiniDump *)ptr);
        break;
    case SOAP_TYPE___ns4__Hello:
        soap_serialize___ns4__Hello(soap, (const struct __ns4__Hello *)ptr);
        break;
    case SOAP_TYPE___ns3__UploadSymbol:
        soap_serialize___ns3__UploadSymbol(soap, (const struct __ns3__UploadSymbol *)ptr);
        break;
    case SOAP_TYPE___ns3__UploadAdditionalInfo:
        soap_serialize___ns3__UploadAdditionalInfo(soap, (const struct __ns3__UploadAdditionalInfo *)ptr);
        break;
    case SOAP_TYPE___ns3__UploadMiniDump:
        soap_serialize___ns3__UploadMiniDump(soap, (const struct __ns3__UploadMiniDump *)ptr);
        break;
    case SOAP_TYPE___ns3__Hello:
        soap_serialize___ns3__Hello(soap, (const struct __ns3__Hello *)ptr);
        break;
    case SOAP_TYPE__xop__Include:
        soap_serialize__xop__Include(soap, (const struct _xop__Include *)ptr);
        break;
    case SOAP_TYPE_PointerTo_ns1__UploadSymbolResponse:
        soap_serialize_PointerTo_ns1__UploadSymbolResponse(soap, (_ns1__UploadSymbolResponse *const*)ptr);
        break;
    case SOAP_TYPE_PointerTo_ns1__UploadSymbol:
        soap_serialize_PointerTo_ns1__UploadSymbol(soap, (_ns1__UploadSymbol *const*)ptr);
        break;
    case SOAP_TYPE_PointerTo_ns1__UploadAdditionalInfoResponse:
        soap_serialize_PointerTo_ns1__UploadAdditionalInfoResponse(soap, (_ns1__UploadAdditionalInfoResponse *const*)ptr);
        break;
    case SOAP_TYPE_PointerTo_ns1__UploadAdditionalInfo:
        soap_serialize_PointerTo_ns1__UploadAdditionalInfo(soap, (_ns1__UploadAdditionalInfo *const*)ptr);
        break;
    case SOAP_TYPE_PointerTo_ns1__UploadMiniDumpResponse:
        soap_serialize_PointerTo_ns1__UploadMiniDumpResponse(soap, (_ns1__UploadMiniDumpResponse *const*)ptr);
        break;
    case SOAP_TYPE_PointerTo_ns1__UploadMiniDump:
        soap_serialize_PointerTo_ns1__UploadMiniDump(soap, (_ns1__UploadMiniDump *const*)ptr);
        break;
    case SOAP_TYPE_PointerTo_ns1__HelloResponse:
        soap_serialize_PointerTo_ns1__HelloResponse(soap, (_ns1__HelloResponse *const*)ptr);
        break;
    case SOAP_TYPE_PointerTo_ns1__Hello:
        soap_serialize_PointerTo_ns1__Hello(soap, (_ns1__Hello *const*)ptr);
        break;
    case SOAP_TYPE_PointerTons1__Response:
        soap_serialize_PointerTons1__Response(soap, (ns1__Response *const*)ptr);
        break;
    case SOAP_TYPE_PointerTons1__Application:
        soap_serialize_PointerTons1__Application(soap, (ns1__Application *const*)ptr);
        break;
    case SOAP_TYPE_PointerTons1__ClientLib:
        soap_serialize_PointerTons1__ClientLib(soap, (ns1__ClientLib *const*)ptr);
        break;
    case SOAP_TYPE_PointerTo_xop__Include:
        soap_serialize_PointerTo_xop__Include(soap, (struct _xop__Include *const*)ptr);
        break;
    case SOAP_TYPE_PointerTons1__Solution:
        soap_serialize_PointerTons1__Solution(soap, (ns1__Solution *const*)ptr);
        break;
    case SOAP_TYPE_PointerTostd__wstring:
        soap_serialize_PointerTostd__wstring(soap, (std::wstring *const*)ptr);
        break;
    case SOAP_TYPE_PointerTounsignedByte:
        soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
        break;
    case SOAP_TYPE__QName:
        soap_serialize_string(soap, (char*const*)&ptr);
        break;
    case SOAP_TYPE_string:
        soap_serialize_string(soap, (char*const*)&ptr);
        break;
    }
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
    switch (t)
    {
    case SOAP_TYPE__xop__Include:
        return (void*)soap_instantiate__xop__Include(soap, -1, type, arrayType, n);
    case SOAP_TYPE_std__wstring:
        return (void*)soap_instantiate_std__wstring(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns1__ClientLib:
        return (void*)soap_instantiate_ns1__ClientLib(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns1__Application:
        return (void*)soap_instantiate_ns1__Application(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns1__Response:
        return (void*)soap_instantiate_ns1__Response(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns1__Solution:
        return (void*)soap_instantiate_ns1__Solution(soap, -1, type, arrayType, n);
    case SOAP_TYPE__ns1__Hello:
        return (void*)soap_instantiate__ns1__Hello(soap, -1, type, arrayType, n);
    case SOAP_TYPE__ns1__HelloResponse:
        return (void*)soap_instantiate__ns1__HelloResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE__ns1__UploadMiniDump:
        return (void*)soap_instantiate__ns1__UploadMiniDump(soap, -1, type, arrayType, n);
    case SOAP_TYPE__ns1__UploadMiniDumpResponse:
        return (void*)soap_instantiate__ns1__UploadMiniDumpResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE__ns1__UploadAdditionalInfo:
        return (void*)soap_instantiate__ns1__UploadAdditionalInfo(soap, -1, type, arrayType, n);
    case SOAP_TYPE__ns1__UploadAdditionalInfoResponse:
        return (void*)soap_instantiate__ns1__UploadAdditionalInfoResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE__ns1__UploadSymbol:
        return (void*)soap_instantiate__ns1__UploadSymbol(soap, -1, type, arrayType, n);
    case SOAP_TYPE__ns1__UploadSymbolResponse:
        return (void*)soap_instantiate__ns1__UploadSymbolResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE___ns3__Hello:
        return (void*)soap_instantiate___ns3__Hello(soap, -1, type, arrayType, n);
    case SOAP_TYPE___ns3__UploadMiniDump:
        return (void*)soap_instantiate___ns3__UploadMiniDump(soap, -1, type, arrayType, n);
    case SOAP_TYPE___ns3__UploadAdditionalInfo:
        return (void*)soap_instantiate___ns3__UploadAdditionalInfo(soap, -1, type, arrayType, n);
    case SOAP_TYPE___ns3__UploadSymbol:
        return (void*)soap_instantiate___ns3__UploadSymbol(soap, -1, type, arrayType, n);
    case SOAP_TYPE___ns4__Hello:
        return (void*)soap_instantiate___ns4__Hello(soap, -1, type, arrayType, n);
    case SOAP_TYPE___ns4__UploadMiniDump:
        return (void*)soap_instantiate___ns4__UploadMiniDump(soap, -1, type, arrayType, n);
    case SOAP_TYPE___ns4__UploadAdditionalInfo:
        return (void*)soap_instantiate___ns4__UploadAdditionalInfo(soap, -1, type, arrayType, n);
    case SOAP_TYPE___ns4__UploadSymbol:
        return (void*)soap_instantiate___ns4__UploadSymbol(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
    case SOAP_TYPE_SOAP_ENV__Header:
        return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
    case SOAP_TYPE_SOAP_ENV__Code:
        return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
    case SOAP_TYPE_SOAP_ENV__Detail:
        return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
    case SOAP_TYPE_SOAP_ENV__Reason:
        return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
    case SOAP_TYPE_SOAP_ENV__Fault:
        return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
    case SOAP_TYPE_ns2__guid:
        return (void*)soap_instantiate_ns2__guid(soap, -1, type, arrayType, n);
    }
    return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{   switch (p->type)
    {
    case SOAP_TYPE__xop__Include:
        if (p->size < 0)
            SOAP_DELETE((struct _xop__Include*)p->ptr);
        else
            SOAP_DELETE_ARRAY((struct _xop__Include*)p->ptr);
        break;
    case SOAP_TYPE_std__wstring:
        if (p->size < 0)
            SOAP_DELETE((std::wstring*)p->ptr);
        else
            SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
        break;
    case SOAP_TYPE_ns1__ClientLib:
        if (p->size < 0)
            SOAP_DELETE((ns1__ClientLib*)p->ptr);
        else
            SOAP_DELETE_ARRAY((ns1__ClientLib*)p->ptr);
        break;
    case SOAP_TYPE_ns1__Application:
        if (p->size < 0)
            SOAP_DELETE((ns1__Application*)p->ptr);
        else
            SOAP_DELETE_ARRAY((ns1__Application*)p->ptr);
        break;
    case SOAP_TYPE_ns1__Response:
        if (p->size < 0)
            SOAP_DELETE((ns1__Response*)p->ptr);
        else
            SOAP_DELETE_ARRAY((ns1__Response*)p->ptr);
        break;
    case SOAP_TYPE_ns1__Solution:
        if (p->size < 0)
            SOAP_DELETE((ns1__Solution*)p->ptr);
        else
            SOAP_DELETE_ARRAY((ns1__Solution*)p->ptr);
        break;
    case SOAP_TYPE__ns1__Hello:
        if (p->size < 0)
            SOAP_DELETE((_ns1__Hello*)p->ptr);
        else
            SOAP_DELETE_ARRAY((_ns1__Hello*)p->ptr);
        break;
    case SOAP_TYPE__ns1__HelloResponse:
        if (p->size < 0)
            SOAP_DELETE((_ns1__HelloResponse*)p->ptr);
        else
            SOAP_DELETE_ARRAY((_ns1__HelloResponse*)p->ptr);
        break;
    case SOAP_TYPE__ns1__UploadMiniDump:
        if (p->size < 0)
            SOAP_DELETE((_ns1__UploadMiniDump*)p->ptr);
        else
            SOAP_DELETE_ARRAY((_ns1__UploadMiniDump*)p->ptr);
        break;
    case SOAP_TYPE__ns1__UploadMiniDumpResponse:
        if (p->size < 0)
            SOAP_DELETE((_ns1__UploadMiniDumpResponse*)p->ptr);
        else
            SOAP_DELETE_ARRAY((_ns1__UploadMiniDumpResponse*)p->ptr);
        break;
    case SOAP_TYPE__ns1__UploadAdditionalInfo:
        if (p->size < 0)
            SOAP_DELETE((_ns1__UploadAdditionalInfo*)p->ptr);
        else
            SOAP_DELETE_ARRAY((_ns1__UploadAdditionalInfo*)p->ptr);
        break;
    case SOAP_TYPE__ns1__UploadAdditionalInfoResponse:
        if (p->size < 0)
            SOAP_DELETE((_ns1__UploadAdditionalInfoResponse*)p->ptr);
        else
            SOAP_DELETE_ARRAY((_ns1__UploadAdditionalInfoResponse*)p->ptr);
        break;
    case SOAP_TYPE__ns1__UploadSymbol:
        if (p->size < 0)
            SOAP_DELETE((_ns1__UploadSymbol*)p->ptr);
        else
            SOAP_DELETE_ARRAY((_ns1__UploadSymbol*)p->ptr);
        break;
    case SOAP_TYPE__ns1__UploadSymbolResponse:
        if (p->size < 0)
            SOAP_DELETE((_ns1__UploadSymbolResponse*)p->ptr);
        else
            SOAP_DELETE_ARRAY((_ns1__UploadSymbolResponse*)p->ptr);
        break;
    case SOAP_TYPE___ns3__Hello:
        if (p->size < 0)
            SOAP_DELETE((struct __ns3__Hello*)p->ptr);
        else
            SOAP_DELETE_ARRAY((struct __ns3__Hello*)p->ptr);
        break;
    case SOAP_TYPE___ns3__UploadMiniDump:
        if (p->size < 0)
            SOAP_DELETE((struct __ns3__UploadMiniDump*)p->ptr);
        else
            SOAP_DELETE_ARRAY((struct __ns3__UploadMiniDump*)p->ptr);
        break;
    case SOAP_TYPE___ns3__UploadAdditionalInfo:
        if (p->size < 0)
            SOAP_DELETE((struct __ns3__UploadAdditionalInfo*)p->ptr);
        else
            SOAP_DELETE_ARRAY((struct __ns3__UploadAdditionalInfo*)p->ptr);
        break;
    case SOAP_TYPE___ns3__UploadSymbol:
        if (p->size < 0)
            SOAP_DELETE((struct __ns3__UploadSymbol*)p->ptr);
        else
            SOAP_DELETE_ARRAY((struct __ns3__UploadSymbol*)p->ptr);
        break;
    case SOAP_TYPE___ns4__Hello:
        if (p->size < 0)
            SOAP_DELETE((struct __ns4__Hello*)p->ptr);
        else
            SOAP_DELETE_ARRAY((struct __ns4__Hello*)p->ptr);
        break;
    case SOAP_TYPE___ns4__UploadMiniDump:
        if (p->size < 0)
            SOAP_DELETE((struct __ns4__UploadMiniDump*)p->ptr);
        else
            SOAP_DELETE_ARRAY((struct __ns4__UploadMiniDump*)p->ptr);
        break;
    case SOAP_TYPE___ns4__UploadAdditionalInfo:
        if (p->size < 0)
            SOAP_DELETE((struct __ns4__UploadAdditionalInfo*)p->ptr);
        else
            SOAP_DELETE_ARRAY((struct __ns4__UploadAdditionalInfo*)p->ptr);
        break;
    case SOAP_TYPE___ns4__UploadSymbol:
        if (p->size < 0)
            SOAP_DELETE((struct __ns4__UploadSymbol*)p->ptr);
        else
            SOAP_DELETE_ARRAY((struct __ns4__UploadSymbol*)p->ptr);
        break;
    case SOAP_TYPE_SOAP_ENV__Header:
        if (p->size < 0)
            SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
        else
            SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
        break;
    case SOAP_TYPE_SOAP_ENV__Code:
        if (p->size < 0)
            SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
        else
            SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
        break;
    case SOAP_TYPE_SOAP_ENV__Detail:
        if (p->size < 0)
            SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
        else
            SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
        break;
    case SOAP_TYPE_SOAP_ENV__Reason:
        if (p->size < 0)
            SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
        else
            SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
        break;
    case SOAP_TYPE_SOAP_ENV__Fault:
        if (p->size < 0)
            SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
        else
            SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
        break;
    case SOAP_TYPE_ns2__guid:
        if (p->size < 0)
            SOAP_DELETE((std::wstring*)p->ptr);
        else
            SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
        break;
    default:    return SOAP_ERR;
    }
    return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{   return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{   return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
    (void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
    switch (tt)
    {
    default:
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
    }
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
    (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
    *a = SOAP_DEFAULT_byte;
#else
    *a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
    return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{   char *p;
    p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
    return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
    if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
    if ((p = soap_in_byte(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{
    (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_short
    *a = SOAP_DEFAULT_short;
#else
    *a = (short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
    return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{   short *p;
    p = soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
    return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
    if (soap_out_short(soap, tag?tag:"short", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
    if ((p = soap_in_short(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
    (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
    *a = SOAP_DEFAULT_int;
#else
    *a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
    return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{   int *p;
    p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
    return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
    if (soap_out_int(soap, tag?tag:"int", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
    if ((p = soap_in_int(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
    (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
    *a = SOAP_DEFAULT_unsignedByte;
#else
    *a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
    return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{   unsigned char *p;
    p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
    return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
    if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
    if ((p = soap_in_unsignedByte(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedShort(struct soap *soap, unsigned short *a)
{
    (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedShort
    *a = SOAP_DEFAULT_unsignedShort;
#else
    *a = (unsigned short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedShort(struct soap *soap, const char *tag, int id, const unsigned short *a, const char *type)
{
    return soap_outunsignedShort(soap, tag, id, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_in_unsignedShort(struct soap *soap, const char *tag, unsigned short *a, const char *type)
{   unsigned short *p;
    p = soap_inunsignedShort(soap, tag, a, type, SOAP_TYPE_unsignedShort);
    return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedShort(struct soap *soap, const unsigned short *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedShort);
    if (soap_out_unsignedShort(soap, tag?tag:"unsignedShort", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_get_unsignedShort(struct soap *soap, unsigned short *p, const char *tag, const char *type)
{
    if ((p = soap_in_unsignedShort(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
    (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
    *a = SOAP_DEFAULT_unsignedInt;
#else
    *a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
    return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{   unsigned int *p;
    p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
    return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
    if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
    if ((p = soap_in_unsignedInt(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
    (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
    *a = SOAP_DEFAULT_bool;
#else
    *a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{   { (long)false, "false" },
    { (long)true, "true" },
    { 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
    (void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{   if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
        return soap->error;
    return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
    const struct soap_code_map *map;
    if (!s)
        return soap->error;
    map = soap_code(soap_codes_bool, s);
    if (map)
        *a = (bool)(map->code != 0);
    else
    {   long n;
        if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
            return soap->error = SOAP_TYPE;
        *a = (bool)(n != 0);
    }
    return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 0, NULL))
        return NULL;
    if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
    {   soap->error = SOAP_TYPE;
        return NULL;
    }
    a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    if (soap->body && !*soap->href)
    {   if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
    if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
    if ((p = soap_in_bool(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AdditionalInfoType(struct soap *soap, enum ns1__AdditionalInfoType *a)
{
    (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__AdditionalInfoType
    *a = SOAP_DEFAULT_ns1__AdditionalInfoType;
#else
    *a = (enum ns1__AdditionalInfoType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__AdditionalInfoType[] =
{   { (long)ns1__AdditionalInfoType__None, "None" },
    { (long)ns1__AdditionalInfoType__FullDump, "FullDump" },
    { (long)ns1__AdditionalInfoType__Info, "Info" },
    { 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__AdditionalInfoType2s(struct soap *soap, enum ns1__AdditionalInfoType n)
{   const char *s = soap_code_str(soap_codes_ns1__AdditionalInfoType, (long)n);
    if (s)
        return s;
    return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AdditionalInfoType(struct soap *soap, const char *tag, int id, const enum ns1__AdditionalInfoType *a, const char *type)
{   if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AdditionalInfoType), type) || soap_send(soap, soap_ns1__AdditionalInfoType2s(soap, *a)))
        return soap->error;
    return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__AdditionalInfoType(struct soap *soap, const char *s, enum ns1__AdditionalInfoType *a)
{
    const struct soap_code_map *map;
    if (!s)
        return soap->error;
    map = soap_code(soap_codes_ns1__AdditionalInfoType, s);
    if (map)
        *a = (enum ns1__AdditionalInfoType)map->code;
    else
    {   long n;
        if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
            return soap->error = SOAP_TYPE;
        *a = (enum ns1__AdditionalInfoType)n;
    }
    return SOAP_OK;
}

SOAP_FMAC3 enum ns1__AdditionalInfoType * SOAP_FMAC4 soap_in_ns1__AdditionalInfoType(struct soap *soap, const char *tag, enum ns1__AdditionalInfoType *a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 0, type))
        return NULL;
    a = (enum ns1__AdditionalInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AdditionalInfoType, sizeof(enum ns1__AdditionalInfoType), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    if (soap->body && !*soap->href)
    {   if (!a || soap_s2ns1__AdditionalInfoType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (enum ns1__AdditionalInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AdditionalInfoType, 0, sizeof(enum ns1__AdditionalInfoType), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AdditionalInfoType(struct soap *soap, const enum ns1__AdditionalInfoType *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__AdditionalInfoType);
    if (soap_out_ns1__AdditionalInfoType(soap, tag?tag:"ns1:AdditionalInfoType", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__AdditionalInfoType * SOAP_FMAC4 soap_get_ns1__AdditionalInfoType(struct soap *soap, enum ns1__AdditionalInfoType *p, const char *tag, const char *type)
{
    if ((p = soap_in_ns1__AdditionalInfoType(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SolutionType(struct soap *soap, enum ns1__SolutionType *a)
{
    (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__SolutionType
    *a = SOAP_DEFAULT_ns1__SolutionType;
#else
    *a = (enum ns1__SolutionType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__SolutionType[] =
{   { (long)ns1__SolutionType__Url, "Url" },
    { (long)ns1__SolutionType__Exe, "Exe" },
    { 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__SolutionType2s(struct soap *soap, enum ns1__SolutionType n)
{   const char *s = soap_code_str(soap_codes_ns1__SolutionType, (long)n);
    if (s)
        return s;
    return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SolutionType(struct soap *soap, const char *tag, int id, const enum ns1__SolutionType *a, const char *type)
{   if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SolutionType), type) || soap_send(soap, soap_ns1__SolutionType2s(soap, *a)))
        return soap->error;
    return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__SolutionType(struct soap *soap, const char *s, enum ns1__SolutionType *a)
{
    const struct soap_code_map *map;
    if (!s)
        return soap->error;
    map = soap_code(soap_codes_ns1__SolutionType, s);
    if (map)
        *a = (enum ns1__SolutionType)map->code;
    else
    {   long n;
        if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
            return soap->error = SOAP_TYPE;
        *a = (enum ns1__SolutionType)n;
    }
    return SOAP_OK;
}

SOAP_FMAC3 enum ns1__SolutionType * SOAP_FMAC4 soap_in_ns1__SolutionType(struct soap *soap, const char *tag, enum ns1__SolutionType *a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 0, type))
        return NULL;
    a = (enum ns1__SolutionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SolutionType, sizeof(enum ns1__SolutionType), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    if (soap->body && !*soap->href)
    {   if (!a || soap_s2ns1__SolutionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (enum ns1__SolutionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SolutionType, 0, sizeof(enum ns1__SolutionType), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SolutionType(struct soap *soap, const enum ns1__SolutionType *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SolutionType);
    if (soap_out_ns1__SolutionType(soap, tag?tag:"ns1:SolutionType", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__SolutionType * SOAP_FMAC4 soap_get_ns1__SolutionType(struct soap *soap, enum ns1__SolutionType *p, const char *tag, const char *type)
{
    if ((p = soap_in_ns1__SolutionType(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ResponseType(struct soap *soap, enum ns1__ResponseType *a)
{
    (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__ResponseType
    *a = SOAP_DEFAULT_ns1__ResponseType;
#else
    *a = (enum ns1__ResponseType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__ResponseType[] =
{   { (long)ns1__ResponseType__HaveSolution, "HaveSolution" },
    { (long)ns1__ResponseType__NeedMiniDump, "NeedMiniDump" },
    { (long)ns1__ResponseType__NeedMoreInfo, "NeedMoreInfo" },
    { (long)ns1__ResponseType__Stop, "Stop" },
    { (long)ns1__ResponseType__Error, "Error" },
    { 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ResponseType2s(struct soap *soap, enum ns1__ResponseType n)
{   const char *s = soap_code_str(soap_codes_ns1__ResponseType, (long)n);
    if (s)
        return s;
    return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ResponseType(struct soap *soap, const char *tag, int id, const enum ns1__ResponseType *a, const char *type)
{   if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ResponseType), type) || soap_send(soap, soap_ns1__ResponseType2s(soap, *a)))
        return soap->error;
    return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ResponseType(struct soap *soap, const char *s, enum ns1__ResponseType *a)
{
    const struct soap_code_map *map;
    if (!s)
        return soap->error;
    map = soap_code(soap_codes_ns1__ResponseType, s);
    if (map)
        *a = (enum ns1__ResponseType)map->code;
    else
    {   long n;
        if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
            return soap->error = SOAP_TYPE;
        *a = (enum ns1__ResponseType)n;
    }
    return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ResponseType * SOAP_FMAC4 soap_in_ns1__ResponseType(struct soap *soap, const char *tag, enum ns1__ResponseType *a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 0, type))
        return NULL;
    a = (enum ns1__ResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ResponseType, sizeof(enum ns1__ResponseType), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    if (soap->body && !*soap->href)
    {   if (!a || soap_s2ns1__ResponseType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (enum ns1__ResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ResponseType, 0, sizeof(enum ns1__ResponseType), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ResponseType(struct soap *soap, const enum ns1__ResponseType *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ResponseType);
    if (soap_out_ns1__ResponseType(soap, tag?tag:"ns1:ResponseType", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ResponseType * SOAP_FMAC4 soap_get_ns1__ResponseType(struct soap *soap, enum ns1__ResponseType *p, const char *tag, const char *type)
{
    if ((p = soap_in_ns1__ResponseType(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Architecture(struct soap *soap, enum ns1__Architecture *a)
{
    (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__Architecture
    *a = SOAP_DEFAULT_ns1__Architecture;
#else
    *a = (enum ns1__Architecture)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__Architecture[] =
{   { (long)ns1__Architecture__x32, "x32" },
    { (long)ns1__Architecture__x64, "x64" },
    { 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__Architecture2s(struct soap *soap, enum ns1__Architecture n)
{   const char *s = soap_code_str(soap_codes_ns1__Architecture, (long)n);
    if (s)
        return s;
    return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Architecture(struct soap *soap, const char *tag, int id, const enum ns1__Architecture *a, const char *type)
{   if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Architecture), type) || soap_send(soap, soap_ns1__Architecture2s(soap, *a)))
        return soap->error;
    return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__Architecture(struct soap *soap, const char *s, enum ns1__Architecture *a)
{
    const struct soap_code_map *map;
    if (!s)
        return soap->error;
    map = soap_code(soap_codes_ns1__Architecture, s);
    if (map)
        *a = (enum ns1__Architecture)map->code;
    else
    {   long n;
        if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
            return soap->error = SOAP_TYPE;
        *a = (enum ns1__Architecture)n;
    }
    return SOAP_OK;
}

SOAP_FMAC3 enum ns1__Architecture * SOAP_FMAC4 soap_in_ns1__Architecture(struct soap *soap, const char *tag, enum ns1__Architecture *a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 0, type))
        return NULL;
    a = (enum ns1__Architecture *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Architecture, sizeof(enum ns1__Architecture), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    if (soap->body && !*soap->href)
    {   if (!a || soap_s2ns1__Architecture(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (enum ns1__Architecture *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Architecture, 0, sizeof(enum ns1__Architecture), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Architecture(struct soap *soap, const enum ns1__Architecture *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Architecture);
    if (soap_out_ns1__Architecture(soap, tag?tag:"ns1:Architecture", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Architecture * SOAP_FMAC4 soap_get_ns1__Architecture(struct soap *soap, enum ns1__Architecture *p, const char *tag, const char *type)
{
    if ((p = soap_in_ns1__Architecture(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__guid(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
    if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
        return soap_element_null(soap, tag, id, type);
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__guid), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_ns2__guid(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
    (void)type; /* appease -Wall -Werror */
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!s)
        s = soap_new_std__wstring(soap, -1);
    if (soap->null)
        if (s)
            s->erase();
    if (soap->body && !*soap->href)
    {   wchar_t *t;
        s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__guid, sizeof(std::wstring), soap->type, soap->arrayType);
        if (s)
        {   if ((t = soap_wstring_in(soap, 1, -1, -1)))
                s->assign(t);
            else
                return NULL;
        }
    }
    else
        s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__guid, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_ns2__guid, 0, sizeof(std::wstring), 0, soap_copy_ns2__guid);
    if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__guid(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__guid);
    if (soap_out_ns2__guid(soap, tag?tag:"ns2:guid", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_ns2__guid(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
    if ((p = soap_in_ns2__guid(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__wstring(struct soap *soap, std::wstring *p)
{
    (void)soap; /* appease -Wall -Werror */
    p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__wstring(struct soap *soap, const std::wstring *p)
{   (void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__wstring(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
    if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
        return soap_element_null(soap, tag, id, type);
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__wstring), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_std__wstring(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
    (void)type; /* appease -Wall -Werror */
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!s)
        s = soap_new_std__wstring(soap, -1);
    if (soap->null)
        if (s)
            s->erase();
    if (soap->body && !*soap->href)
    {   wchar_t *t;
        s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType);
        if (s)
        {   if ((t = soap_wstring_in(soap, 1, -1, -1)))
                s->assign(t);
            else
                return NULL;
        }
    }
    else
        s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_std__wstring, 0, sizeof(std::wstring), 0, soap_copy_std__wstring);
    if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__wstring(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__wstring);
    if (soap_out_std__wstring(soap, tag?tag:"string", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_std__wstring(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
    if ((p = soap_in_std__wstring(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 std::wstring * SOAP_FMAC2 soap_instantiate_std__wstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__wstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__wstring, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(std::wstring);
        if (size)
            *size = sizeof(std::wstring);
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(std::wstring[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(std::wstring);
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (std::wstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__wstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::wstring %p -> %p\n", q, p));
    *(std::wstring*)p = *(std::wstring*)q;
}

void _ns1__UploadSymbolResponse::soap_default(struct soap *soap)
{
    this->soap = soap;
    this->_ns1__UploadSymbolResponse::UploadSymbolResult = NULL;
    /* transient soap skipped */
}

void _ns1__UploadSymbolResponse::soap_serialize(struct soap *soap) const
{
    (void)soap; /* appease -Wall -Werror */
    soap_serialize_PointerTostd__wstring(soap, &this->_ns1__UploadSymbolResponse::UploadSymbolResult);
    /* transient soap skipped */
}

int _ns1__UploadSymbolResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
    return soap_out__ns1__UploadSymbolResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadSymbolResponse(struct soap *soap, const char *tag, int id, const _ns1__UploadSymbolResponse *a, const char *type)
{
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadSymbolResponse), type))
        return soap->error;
    if (a->UploadSymbolResult)
        soap_element_result(soap, "ns1:UploadSymbolResult");
    if (soap_out_PointerTostd__wstring(soap, "ns1:UploadSymbolResult", -1, &(a->_ns1__UploadSymbolResponse::UploadSymbolResult), ""))
        return soap->error;
    /* transient soap skipped */
    return soap_element_end_out(soap, tag);
}

void *_ns1__UploadSymbolResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{   return soap_in__ns1__UploadSymbolResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadSymbolResponse * SOAP_FMAC4 soap_in__ns1__UploadSymbolResponse(struct soap *soap, const char *tag, _ns1__UploadSymbolResponse *a, const char *type)
{
    (void)type; /* appease -Wall -Werror */
    if (soap_element_begin_in(soap, tag, 0, NULL))
        return NULL;
    a = (_ns1__UploadSymbolResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadSymbolResponse, sizeof(_ns1__UploadSymbolResponse), soap->type, soap->arrayType);
    if (!a)
        return NULL;
    if (soap->alloced)
    {   a->soap_default(soap);
        if (soap->clist->type != SOAP_TYPE__ns1__UploadSymbolResponse)
        {   soap_revert(soap);
            *soap->id = '\0';
            return (_ns1__UploadSymbolResponse *)a->soap_in(soap, tag, type);
        }
    }
    size_t soap_flag_UploadSymbolResult1 = 1;
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_UploadSymbolResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in_PointerTostd__wstring(soap, "ns1:UploadSymbolResult", &(a->_ns1__UploadSymbolResponse::UploadSymbolResult), "xsd:string"))
                {   soap_flag_UploadSymbolResult1--;
                    continue;
                }
            /* transient soap skipped */
            soap_check_result(soap, "ns1:UploadSymbolResult");
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (_ns1__UploadSymbolResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadSymbolResponse, 0, sizeof(_ns1__UploadSymbolResponse), 0, soap_copy__ns1__UploadSymbolResponse);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

int _ns1__UploadSymbolResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
    register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UploadSymbolResponse);
    if (this->soap_out(soap, tag?tag:"ns1:UploadSymbolResponse", id, type))
        return soap->error;
    return soap_putindependent(soap);
}

void *_ns1__UploadSymbolResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
    return soap_get__ns1__UploadSymbolResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadSymbolResponse * SOAP_FMAC4 soap_get__ns1__UploadSymbolResponse(struct soap *soap, _ns1__UploadSymbolResponse *p, const char *tag, const char *type)
{
    if ((p = soap_in__ns1__UploadSymbolResponse(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 _ns1__UploadSymbolResponse * SOAP_FMAC2 soap_instantiate__ns1__UploadSymbolResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadSymbolResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UploadSymbolResponse, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(_ns1__UploadSymbolResponse);
        if (size)
            *size = sizeof(_ns1__UploadSymbolResponse);
        ((_ns1__UploadSymbolResponse*)cp->ptr)->soap = soap;
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(_ns1__UploadSymbolResponse[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(_ns1__UploadSymbolResponse);
        for (int i = 0; i < n; i++)
            ((_ns1__UploadSymbolResponse*)cp->ptr)[i].soap = soap;
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (_ns1__UploadSymbolResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UploadSymbolResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UploadSymbolResponse %p -> %p\n", q, p));
    *(_ns1__UploadSymbolResponse*)p = *(_ns1__UploadSymbolResponse*)q;
}

void _ns1__UploadSymbol::soap_default(struct soap *soap)
{
    this->soap = soap;
    this->_ns1__UploadSymbol::client = NULL;
    this->_ns1__UploadSymbol::app = NULL;
    soap_default_bool(soap, &this->_ns1__UploadSymbol::publish);
    this->_ns1__UploadSymbol::sym = NULL;
    /* transient soap skipped */
}

void _ns1__UploadSymbol::soap_serialize(struct soap *soap) const
{
    (void)soap; /* appease -Wall -Werror */
    soap_serialize_PointerTons1__ClientLib(soap, &this->_ns1__UploadSymbol::client);
    soap_serialize_PointerTons1__Application(soap, &this->_ns1__UploadSymbol::app);
    soap_serialize_PointerTo_xop__Include(soap, &this->_ns1__UploadSymbol::sym);
    /* transient soap skipped */
}

int _ns1__UploadSymbol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
    return soap_out__ns1__UploadSymbol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadSymbol(struct soap *soap, const char *tag, int id, const _ns1__UploadSymbol *a, const char *type)
{
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadSymbol), type))
        return soap->error;
    if (soap_out_PointerTons1__ClientLib(soap, "ns1:client", -1, &(a->_ns1__UploadSymbol::client), ""))
        return soap->error;
    if (soap_out_PointerTons1__Application(soap, "ns1:app", -1, &(a->_ns1__UploadSymbol::app), ""))
        return soap->error;
    if (soap_out_bool(soap, "ns1:publish", -1, &(a->_ns1__UploadSymbol::publish), ""))
        return soap->error;
    if (soap_out_PointerTo_xop__Include(soap, "ns1:sym", -1, &(a->_ns1__UploadSymbol::sym), ""))
        return soap->error;
    /* transient soap skipped */
    return soap_element_end_out(soap, tag);
}

void *_ns1__UploadSymbol::soap_in(struct soap *soap, const char *tag, const char *type)
{   return soap_in__ns1__UploadSymbol(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadSymbol * SOAP_FMAC4 soap_in__ns1__UploadSymbol(struct soap *soap, const char *tag, _ns1__UploadSymbol *a, const char *type)
{
    (void)type; /* appease -Wall -Werror */
    if (soap_element_begin_in(soap, tag, 0, NULL))
        return NULL;
    a = (_ns1__UploadSymbol *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadSymbol, sizeof(_ns1__UploadSymbol), soap->type, soap->arrayType);
    if (!a)
        return NULL;
    if (soap->alloced)
    {   a->soap_default(soap);
        if (soap->clist->type != SOAP_TYPE__ns1__UploadSymbol)
        {   soap_revert(soap);
            *soap->id = '\0';
            return (_ns1__UploadSymbol *)a->soap_in(soap, tag, type);
        }
    }
    size_t soap_flag_client1 = 1;
    size_t soap_flag_app1 = 1;
    size_t soap_flag_publish1 = 1;
    size_t soap_flag_sym1 = 1;
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_client1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTons1__ClientLib(soap, "ns1:client", &(a->_ns1__UploadSymbol::client), "ns1:ClientLib"))
                {   soap_flag_client1--;
                    continue;
                }
            if (soap_flag_app1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTons1__Application(soap, "ns1:app", &(a->_ns1__UploadSymbol::app), "ns1:Application"))
                {   soap_flag_app1--;
                    continue;
                }
            if (soap_flag_publish1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_bool(soap, "ns1:publish", &(a->_ns1__UploadSymbol::publish), "xsd:boolean"))
                {   soap_flag_publish1--;
                    continue;
                }
            if (soap_flag_sym1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTo_xop__Include(soap, "ns1:sym", &(a->_ns1__UploadSymbol::sym), ""))
                {   soap_flag_sym1--;
                    continue;
                }
            /* transient soap skipped */
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (_ns1__UploadSymbol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadSymbol, 0, sizeof(_ns1__UploadSymbol), 0, soap_copy__ns1__UploadSymbol);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_publish1 > 0))
    {   soap->error = SOAP_OCCURS;
        return NULL;
    }
    return a;
}

int _ns1__UploadSymbol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
    register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UploadSymbol);
    if (this->soap_out(soap, tag?tag:"ns1:UploadSymbol", id, type))
        return soap->error;
    return soap_putindependent(soap);
}

void *_ns1__UploadSymbol::soap_get(struct soap *soap, const char *tag, const char *type)
{
    return soap_get__ns1__UploadSymbol(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadSymbol * SOAP_FMAC4 soap_get__ns1__UploadSymbol(struct soap *soap, _ns1__UploadSymbol *p, const char *tag, const char *type)
{
    if ((p = soap_in__ns1__UploadSymbol(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 _ns1__UploadSymbol * SOAP_FMAC2 soap_instantiate__ns1__UploadSymbol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadSymbol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UploadSymbol, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(_ns1__UploadSymbol);
        if (size)
            *size = sizeof(_ns1__UploadSymbol);
        ((_ns1__UploadSymbol*)cp->ptr)->soap = soap;
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(_ns1__UploadSymbol[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(_ns1__UploadSymbol);
        for (int i = 0; i < n; i++)
            ((_ns1__UploadSymbol*)cp->ptr)[i].soap = soap;
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (_ns1__UploadSymbol*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UploadSymbol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UploadSymbol %p -> %p\n", q, p));
    *(_ns1__UploadSymbol*)p = *(_ns1__UploadSymbol*)q;
}

void _ns1__UploadAdditionalInfoResponse::soap_default(struct soap *soap)
{
    this->soap = soap;
    this->_ns1__UploadAdditionalInfoResponse::UploadAdditionalInfoResult = NULL;
    /* transient soap skipped */
}

void _ns1__UploadAdditionalInfoResponse::soap_serialize(struct soap *soap) const
{
    (void)soap; /* appease -Wall -Werror */
    soap_serialize_PointerTons1__Response(soap, &this->_ns1__UploadAdditionalInfoResponse::UploadAdditionalInfoResult);
    /* transient soap skipped */
}

int _ns1__UploadAdditionalInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
    return soap_out__ns1__UploadAdditionalInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadAdditionalInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__UploadAdditionalInfoResponse *a, const char *type)
{
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadAdditionalInfoResponse), type))
        return soap->error;
    if (a->UploadAdditionalInfoResult)
        soap_element_result(soap, "ns1:UploadAdditionalInfoResult");
    if (soap_out_PointerTons1__Response(soap, "ns1:UploadAdditionalInfoResult", -1, &(a->_ns1__UploadAdditionalInfoResponse::UploadAdditionalInfoResult), ""))
        return soap->error;
    /* transient soap skipped */
    return soap_element_end_out(soap, tag);
}

void *_ns1__UploadAdditionalInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{   return soap_in__ns1__UploadAdditionalInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadAdditionalInfoResponse * SOAP_FMAC4 soap_in__ns1__UploadAdditionalInfoResponse(struct soap *soap, const char *tag, _ns1__UploadAdditionalInfoResponse *a, const char *type)
{
    (void)type; /* appease -Wall -Werror */
    if (soap_element_begin_in(soap, tag, 0, NULL))
        return NULL;
    a = (_ns1__UploadAdditionalInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadAdditionalInfoResponse, sizeof(_ns1__UploadAdditionalInfoResponse), soap->type, soap->arrayType);
    if (!a)
        return NULL;
    if (soap->alloced)
    {   a->soap_default(soap);
        if (soap->clist->type != SOAP_TYPE__ns1__UploadAdditionalInfoResponse)
        {   soap_revert(soap);
            *soap->id = '\0';
            return (_ns1__UploadAdditionalInfoResponse *)a->soap_in(soap, tag, type);
        }
    }
    size_t soap_flag_UploadAdditionalInfoResult1 = 1;
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_UploadAdditionalInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTons1__Response(soap, "ns1:UploadAdditionalInfoResult", &(a->_ns1__UploadAdditionalInfoResponse::UploadAdditionalInfoResult), "ns1:Response"))
                {   soap_flag_UploadAdditionalInfoResult1--;
                    continue;
                }
            /* transient soap skipped */
            soap_check_result(soap, "ns1:UploadAdditionalInfoResult");
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (_ns1__UploadAdditionalInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadAdditionalInfoResponse, 0, sizeof(_ns1__UploadAdditionalInfoResponse), 0, soap_copy__ns1__UploadAdditionalInfoResponse);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

int _ns1__UploadAdditionalInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
    register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UploadAdditionalInfoResponse);
    if (this->soap_out(soap, tag?tag:"ns1:UploadAdditionalInfoResponse", id, type))
        return soap->error;
    return soap_putindependent(soap);
}

void *_ns1__UploadAdditionalInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
    return soap_get__ns1__UploadAdditionalInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadAdditionalInfoResponse * SOAP_FMAC4 soap_get__ns1__UploadAdditionalInfoResponse(struct soap *soap, _ns1__UploadAdditionalInfoResponse *p, const char *tag, const char *type)
{
    if ((p = soap_in__ns1__UploadAdditionalInfoResponse(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 _ns1__UploadAdditionalInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__UploadAdditionalInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadAdditionalInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UploadAdditionalInfoResponse, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(_ns1__UploadAdditionalInfoResponse);
        if (size)
            *size = sizeof(_ns1__UploadAdditionalInfoResponse);
        ((_ns1__UploadAdditionalInfoResponse*)cp->ptr)->soap = soap;
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(_ns1__UploadAdditionalInfoResponse[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(_ns1__UploadAdditionalInfoResponse);
        for (int i = 0; i < n; i++)
            ((_ns1__UploadAdditionalInfoResponse*)cp->ptr)[i].soap = soap;
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (_ns1__UploadAdditionalInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UploadAdditionalInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UploadAdditionalInfoResponse %p -> %p\n", q, p));
    *(_ns1__UploadAdditionalInfoResponse*)p = *(_ns1__UploadAdditionalInfoResponse*)q;
}

void _ns1__UploadAdditionalInfo::soap_default(struct soap *soap)
{
    this->soap = soap;
    this->_ns1__UploadAdditionalInfo::client = NULL;
    this->_ns1__UploadAdditionalInfo::app = NULL;
    this->_ns1__UploadAdditionalInfo::mainModule = NULL;
    soap_default_int(soap, &this->_ns1__UploadAdditionalInfo::miniDumpID);
    this->_ns1__UploadAdditionalInfo::info = NULL;
    soap_default_ns1__AdditionalInfoType(soap, &this->_ns1__UploadAdditionalInfo::infoType);
    /* transient soap skipped */
}

void _ns1__UploadAdditionalInfo::soap_serialize(struct soap *soap) const
{
    (void)soap; /* appease -Wall -Werror */
    soap_serialize_PointerTons1__ClientLib(soap, &this->_ns1__UploadAdditionalInfo::client);
    soap_serialize_PointerTons1__Application(soap, &this->_ns1__UploadAdditionalInfo::app);
    soap_serialize_PointerTostd__wstring(soap, &this->_ns1__UploadAdditionalInfo::mainModule);
    soap_serialize_PointerTo_xop__Include(soap, &this->_ns1__UploadAdditionalInfo::info);
    /* transient soap skipped */
}

int _ns1__UploadAdditionalInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
    return soap_out__ns1__UploadAdditionalInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadAdditionalInfo(struct soap *soap, const char *tag, int id, const _ns1__UploadAdditionalInfo *a, const char *type)
{
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadAdditionalInfo), type))
        return soap->error;
    if (soap_out_PointerTons1__ClientLib(soap, "ns1:client", -1, &(a->_ns1__UploadAdditionalInfo::client), ""))
        return soap->error;
    if (soap_out_PointerTons1__Application(soap, "ns1:app", -1, &(a->_ns1__UploadAdditionalInfo::app), ""))
        return soap->error;
    if (soap_out_PointerTostd__wstring(soap, "ns1:mainModule", -1, &(a->_ns1__UploadAdditionalInfo::mainModule), ""))
        return soap->error;
    if (soap_out_int(soap, "ns1:miniDumpID", -1, &(a->_ns1__UploadAdditionalInfo::miniDumpID), ""))
        return soap->error;
    if (soap_out_PointerTo_xop__Include(soap, "ns1:info", -1, &(a->_ns1__UploadAdditionalInfo::info), ""))
        return soap->error;
    if (soap_out_ns1__AdditionalInfoType(soap, "ns1:infoType", -1, &(a->_ns1__UploadAdditionalInfo::infoType), ""))
        return soap->error;
    /* transient soap skipped */
    return soap_element_end_out(soap, tag);
}

void *_ns1__UploadAdditionalInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{   return soap_in__ns1__UploadAdditionalInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadAdditionalInfo * SOAP_FMAC4 soap_in__ns1__UploadAdditionalInfo(struct soap *soap, const char *tag, _ns1__UploadAdditionalInfo *a, const char *type)
{
    (void)type; /* appease -Wall -Werror */
    if (soap_element_begin_in(soap, tag, 0, NULL))
        return NULL;
    a = (_ns1__UploadAdditionalInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadAdditionalInfo, sizeof(_ns1__UploadAdditionalInfo), soap->type, soap->arrayType);
    if (!a)
        return NULL;
    if (soap->alloced)
    {   a->soap_default(soap);
        if (soap->clist->type != SOAP_TYPE__ns1__UploadAdditionalInfo)
        {   soap_revert(soap);
            *soap->id = '\0';
            return (_ns1__UploadAdditionalInfo *)a->soap_in(soap, tag, type);
        }
    }
    size_t soap_flag_client1 = 1;
    size_t soap_flag_app1 = 1;
    size_t soap_flag_mainModule1 = 1;
    size_t soap_flag_miniDumpID1 = 1;
    size_t soap_flag_info1 = 1;
    size_t soap_flag_infoType1 = 1;
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_client1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTons1__ClientLib(soap, "ns1:client", &(a->_ns1__UploadAdditionalInfo::client), "ns1:ClientLib"))
                {   soap_flag_client1--;
                    continue;
                }
            if (soap_flag_app1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTons1__Application(soap, "ns1:app", &(a->_ns1__UploadAdditionalInfo::app), "ns1:Application"))
                {   soap_flag_app1--;
                    continue;
                }
            if (soap_flag_mainModule1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in_PointerTostd__wstring(soap, "ns1:mainModule", &(a->_ns1__UploadAdditionalInfo::mainModule), "xsd:string"))
                {   soap_flag_mainModule1--;
                    continue;
                }
            if (soap_flag_miniDumpID1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_int(soap, "ns1:miniDumpID", &(a->_ns1__UploadAdditionalInfo::miniDumpID), "xsd:int"))
                {   soap_flag_miniDumpID1--;
                    continue;
                }
            if (soap_flag_info1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTo_xop__Include(soap, "ns1:info", &(a->_ns1__UploadAdditionalInfo::info), ""))
                {   soap_flag_info1--;
                    continue;
                }
            if (soap_flag_infoType1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_ns1__AdditionalInfoType(soap, "ns1:infoType", &(a->_ns1__UploadAdditionalInfo::infoType), "ns1:AdditionalInfoType"))
                {   soap_flag_infoType1--;
                    continue;
                }
            /* transient soap skipped */
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (_ns1__UploadAdditionalInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadAdditionalInfo, 0, sizeof(_ns1__UploadAdditionalInfo), 0, soap_copy__ns1__UploadAdditionalInfo);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_miniDumpID1 > 0 || soap_flag_infoType1 > 0))
    {   soap->error = SOAP_OCCURS;
        return NULL;
    }
    return a;
}

int _ns1__UploadAdditionalInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
    register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UploadAdditionalInfo);
    if (this->soap_out(soap, tag?tag:"ns1:UploadAdditionalInfo", id, type))
        return soap->error;
    return soap_putindependent(soap);
}

void *_ns1__UploadAdditionalInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
    return soap_get__ns1__UploadAdditionalInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadAdditionalInfo * SOAP_FMAC4 soap_get__ns1__UploadAdditionalInfo(struct soap *soap, _ns1__UploadAdditionalInfo *p, const char *tag, const char *type)
{
    if ((p = soap_in__ns1__UploadAdditionalInfo(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 _ns1__UploadAdditionalInfo * SOAP_FMAC2 soap_instantiate__ns1__UploadAdditionalInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadAdditionalInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UploadAdditionalInfo, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(_ns1__UploadAdditionalInfo);
        if (size)
            *size = sizeof(_ns1__UploadAdditionalInfo);
        ((_ns1__UploadAdditionalInfo*)cp->ptr)->soap = soap;
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(_ns1__UploadAdditionalInfo[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(_ns1__UploadAdditionalInfo);
        for (int i = 0; i < n; i++)
            ((_ns1__UploadAdditionalInfo*)cp->ptr)[i].soap = soap;
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (_ns1__UploadAdditionalInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UploadAdditionalInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UploadAdditionalInfo %p -> %p\n", q, p));
    *(_ns1__UploadAdditionalInfo*)p = *(_ns1__UploadAdditionalInfo*)q;
}

void _ns1__UploadMiniDumpResponse::soap_default(struct soap *soap)
{
    this->soap = soap;
    this->_ns1__UploadMiniDumpResponse::UploadMiniDumpResult = NULL;
    /* transient soap skipped */
}

void _ns1__UploadMiniDumpResponse::soap_serialize(struct soap *soap) const
{
    (void)soap; /* appease -Wall -Werror */
    soap_serialize_PointerTons1__Response(soap, &this->_ns1__UploadMiniDumpResponse::UploadMiniDumpResult);
    /* transient soap skipped */
}

int _ns1__UploadMiniDumpResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
    return soap_out__ns1__UploadMiniDumpResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadMiniDumpResponse(struct soap *soap, const char *tag, int id, const _ns1__UploadMiniDumpResponse *a, const char *type)
{
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadMiniDumpResponse), type))
        return soap->error;
    if (a->UploadMiniDumpResult)
        soap_element_result(soap, "ns1:UploadMiniDumpResult");
    if (soap_out_PointerTons1__Response(soap, "ns1:UploadMiniDumpResult", -1, &(a->_ns1__UploadMiniDumpResponse::UploadMiniDumpResult), ""))
        return soap->error;
    /* transient soap skipped */
    return soap_element_end_out(soap, tag);
}

void *_ns1__UploadMiniDumpResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{   return soap_in__ns1__UploadMiniDumpResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadMiniDumpResponse * SOAP_FMAC4 soap_in__ns1__UploadMiniDumpResponse(struct soap *soap, const char *tag, _ns1__UploadMiniDumpResponse *a, const char *type)
{
    (void)type; /* appease -Wall -Werror */
    if (soap_element_begin_in(soap, tag, 0, NULL))
        return NULL;
    a = (_ns1__UploadMiniDumpResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadMiniDumpResponse, sizeof(_ns1__UploadMiniDumpResponse), soap->type, soap->arrayType);
    if (!a)
        return NULL;
    if (soap->alloced)
    {   a->soap_default(soap);
        if (soap->clist->type != SOAP_TYPE__ns1__UploadMiniDumpResponse)
        {   soap_revert(soap);
            *soap->id = '\0';
            return (_ns1__UploadMiniDumpResponse *)a->soap_in(soap, tag, type);
        }
    }
    size_t soap_flag_UploadMiniDumpResult1 = 1;
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_UploadMiniDumpResult1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTons1__Response(soap, "ns1:UploadMiniDumpResult", &(a->_ns1__UploadMiniDumpResponse::UploadMiniDumpResult), "ns1:Response"))
                {   soap_flag_UploadMiniDumpResult1--;
                    continue;
                }
            /* transient soap skipped */
            soap_check_result(soap, "ns1:UploadMiniDumpResult");
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (_ns1__UploadMiniDumpResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadMiniDumpResponse, 0, sizeof(_ns1__UploadMiniDumpResponse), 0, soap_copy__ns1__UploadMiniDumpResponse);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

int _ns1__UploadMiniDumpResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
    register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UploadMiniDumpResponse);
    if (this->soap_out(soap, tag?tag:"ns1:UploadMiniDumpResponse", id, type))
        return soap->error;
    return soap_putindependent(soap);
}

void *_ns1__UploadMiniDumpResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
    return soap_get__ns1__UploadMiniDumpResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadMiniDumpResponse * SOAP_FMAC4 soap_get__ns1__UploadMiniDumpResponse(struct soap *soap, _ns1__UploadMiniDumpResponse *p, const char *tag, const char *type)
{
    if ((p = soap_in__ns1__UploadMiniDumpResponse(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 _ns1__UploadMiniDumpResponse * SOAP_FMAC2 soap_instantiate__ns1__UploadMiniDumpResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadMiniDumpResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UploadMiniDumpResponse, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(_ns1__UploadMiniDumpResponse);
        if (size)
            *size = sizeof(_ns1__UploadMiniDumpResponse);
        ((_ns1__UploadMiniDumpResponse*)cp->ptr)->soap = soap;
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(_ns1__UploadMiniDumpResponse[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(_ns1__UploadMiniDumpResponse);
        for (int i = 0; i < n; i++)
            ((_ns1__UploadMiniDumpResponse*)cp->ptr)[i].soap = soap;
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (_ns1__UploadMiniDumpResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UploadMiniDumpResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UploadMiniDumpResponse %p -> %p\n", q, p));
    *(_ns1__UploadMiniDumpResponse*)p = *(_ns1__UploadMiniDumpResponse*)q;
}

void _ns1__UploadMiniDump::soap_default(struct soap *soap)
{
    this->soap = soap;
    this->_ns1__UploadMiniDump::client = NULL;
    this->_ns1__UploadMiniDump::app = NULL;
    this->_ns1__UploadMiniDump::mainModule = NULL;
    soap_default_int(soap, &this->_ns1__UploadMiniDump::PCID);
    soap_default_int(soap, &this->_ns1__UploadMiniDump::submitterID);
    this->_ns1__UploadMiniDump::dump = NULL;
    /* transient soap skipped */
}

void _ns1__UploadMiniDump::soap_serialize(struct soap *soap) const
{
    (void)soap; /* appease -Wall -Werror */
    soap_serialize_PointerTons1__ClientLib(soap, &this->_ns1__UploadMiniDump::client);
    soap_serialize_PointerTons1__Application(soap, &this->_ns1__UploadMiniDump::app);
    soap_serialize_PointerTostd__wstring(soap, &this->_ns1__UploadMiniDump::mainModule);
    soap_serialize_PointerTo_xop__Include(soap, &this->_ns1__UploadMiniDump::dump);
    /* transient soap skipped */
}

int _ns1__UploadMiniDump::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
    return soap_out__ns1__UploadMiniDump(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadMiniDump(struct soap *soap, const char *tag, int id, const _ns1__UploadMiniDump *a, const char *type)
{
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadMiniDump), type))
        return soap->error;
    if (soap_out_PointerTons1__ClientLib(soap, "ns1:client", -1, &(a->_ns1__UploadMiniDump::client), ""))
        return soap->error;
    if (soap_out_PointerTons1__Application(soap, "ns1:app", -1, &(a->_ns1__UploadMiniDump::app), ""))
        return soap->error;
    if (soap_out_PointerTostd__wstring(soap, "ns1:mainModule", -1, &(a->_ns1__UploadMiniDump::mainModule), ""))
        return soap->error;
    if (soap_out_int(soap, "ns1:PCID", -1, &(a->_ns1__UploadMiniDump::PCID), ""))
        return soap->error;
    if (soap_out_int(soap, "ns1:submitterID", -1, &(a->_ns1__UploadMiniDump::submitterID), ""))
        return soap->error;
    if (soap_out_PointerTo_xop__Include(soap, "ns1:dump", -1, &(a->_ns1__UploadMiniDump::dump), ""))
        return soap->error;
    /* transient soap skipped */
    return soap_element_end_out(soap, tag);
}

void *_ns1__UploadMiniDump::soap_in(struct soap *soap, const char *tag, const char *type)
{   return soap_in__ns1__UploadMiniDump(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadMiniDump * SOAP_FMAC4 soap_in__ns1__UploadMiniDump(struct soap *soap, const char *tag, _ns1__UploadMiniDump *a, const char *type)
{
    (void)type; /* appease -Wall -Werror */
    if (soap_element_begin_in(soap, tag, 0, NULL))
        return NULL;
    a = (_ns1__UploadMiniDump *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadMiniDump, sizeof(_ns1__UploadMiniDump), soap->type, soap->arrayType);
    if (!a)
        return NULL;
    if (soap->alloced)
    {   a->soap_default(soap);
        if (soap->clist->type != SOAP_TYPE__ns1__UploadMiniDump)
        {   soap_revert(soap);
            *soap->id = '\0';
            return (_ns1__UploadMiniDump *)a->soap_in(soap, tag, type);
        }
    }
    size_t soap_flag_client1 = 1;
    size_t soap_flag_app1 = 1;
    size_t soap_flag_mainModule1 = 1;
    size_t soap_flag_PCID1 = 1;
    size_t soap_flag_submitterID1 = 1;
    size_t soap_flag_dump1 = 1;
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_client1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTons1__ClientLib(soap, "ns1:client", &(a->_ns1__UploadMiniDump::client), "ns1:ClientLib"))
                {   soap_flag_client1--;
                    continue;
                }
            if (soap_flag_app1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTons1__Application(soap, "ns1:app", &(a->_ns1__UploadMiniDump::app), "ns1:Application"))
                {   soap_flag_app1--;
                    continue;
                }
            if (soap_flag_mainModule1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in_PointerTostd__wstring(soap, "ns1:mainModule", &(a->_ns1__UploadMiniDump::mainModule), "xsd:string"))
                {   soap_flag_mainModule1--;
                    continue;
                }
            if (soap_flag_PCID1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_int(soap, "ns1:PCID", &(a->_ns1__UploadMiniDump::PCID), "xsd:int"))
                {   soap_flag_PCID1--;
                    continue;
                }
            if (soap_flag_submitterID1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_int(soap, "ns1:submitterID", &(a->_ns1__UploadMiniDump::submitterID), "xsd:int"))
                {   soap_flag_submitterID1--;
                    continue;
                }
            if (soap_flag_dump1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTo_xop__Include(soap, "ns1:dump", &(a->_ns1__UploadMiniDump::dump), ""))
                {   soap_flag_dump1--;
                    continue;
                }
            /* transient soap skipped */
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (_ns1__UploadMiniDump *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadMiniDump, 0, sizeof(_ns1__UploadMiniDump), 0, soap_copy__ns1__UploadMiniDump);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PCID1 > 0 || soap_flag_submitterID1 > 0))
    {   soap->error = SOAP_OCCURS;
        return NULL;
    }
    return a;
}

int _ns1__UploadMiniDump::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
    register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UploadMiniDump);
    if (this->soap_out(soap, tag?tag:"ns1:UploadMiniDump", id, type))
        return soap->error;
    return soap_putindependent(soap);
}

void *_ns1__UploadMiniDump::soap_get(struct soap *soap, const char *tag, const char *type)
{
    return soap_get__ns1__UploadMiniDump(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadMiniDump * SOAP_FMAC4 soap_get__ns1__UploadMiniDump(struct soap *soap, _ns1__UploadMiniDump *p, const char *tag, const char *type)
{
    if ((p = soap_in__ns1__UploadMiniDump(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 _ns1__UploadMiniDump * SOAP_FMAC2 soap_instantiate__ns1__UploadMiniDump(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadMiniDump(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UploadMiniDump, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(_ns1__UploadMiniDump);
        if (size)
            *size = sizeof(_ns1__UploadMiniDump);
        ((_ns1__UploadMiniDump*)cp->ptr)->soap = soap;
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(_ns1__UploadMiniDump[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(_ns1__UploadMiniDump);
        for (int i = 0; i < n; i++)
            ((_ns1__UploadMiniDump*)cp->ptr)[i].soap = soap;
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (_ns1__UploadMiniDump*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UploadMiniDump(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UploadMiniDump %p -> %p\n", q, p));
    *(_ns1__UploadMiniDump*)p = *(_ns1__UploadMiniDump*)q;
}

void _ns1__HelloResponse::soap_default(struct soap *soap)
{
    this->soap = soap;
    this->_ns1__HelloResponse::HelloResult = NULL;
    /* transient soap skipped */
}

void _ns1__HelloResponse::soap_serialize(struct soap *soap) const
{
    (void)soap; /* appease -Wall -Werror */
    soap_serialize_PointerTons1__Response(soap, &this->_ns1__HelloResponse::HelloResult);
    /* transient soap skipped */
}

int _ns1__HelloResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
    return soap_out__ns1__HelloResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__HelloResponse(struct soap *soap, const char *tag, int id, const _ns1__HelloResponse *a, const char *type)
{
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__HelloResponse), type))
        return soap->error;
    if (a->HelloResult)
        soap_element_result(soap, "ns1:HelloResult");
    if (soap_out_PointerTons1__Response(soap, "ns1:HelloResult", -1, &(a->_ns1__HelloResponse::HelloResult), ""))
        return soap->error;
    /* transient soap skipped */
    return soap_element_end_out(soap, tag);
}

void *_ns1__HelloResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{   return soap_in__ns1__HelloResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__HelloResponse * SOAP_FMAC4 soap_in__ns1__HelloResponse(struct soap *soap, const char *tag, _ns1__HelloResponse *a, const char *type)
{
    (void)type; /* appease -Wall -Werror */
    if (soap_element_begin_in(soap, tag, 0, NULL))
        return NULL;
    a = (_ns1__HelloResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__HelloResponse, sizeof(_ns1__HelloResponse), soap->type, soap->arrayType);
    if (!a)
        return NULL;
    if (soap->alloced)
    {   a->soap_default(soap);
        if (soap->clist->type != SOAP_TYPE__ns1__HelloResponse)
        {   soap_revert(soap);
            *soap->id = '\0';
            return (_ns1__HelloResponse *)a->soap_in(soap, tag, type);
        }
    }
    size_t soap_flag_HelloResult1 = 1;
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_HelloResult1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTons1__Response(soap, "ns1:HelloResult", &(a->_ns1__HelloResponse::HelloResult), "ns1:Response"))
                {   soap_flag_HelloResult1--;
                    continue;
                }
            /* transient soap skipped */
            soap_check_result(soap, "ns1:HelloResult");
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (_ns1__HelloResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__HelloResponse, 0, sizeof(_ns1__HelloResponse), 0, soap_copy__ns1__HelloResponse);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

int _ns1__HelloResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
    register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__HelloResponse);
    if (this->soap_out(soap, tag?tag:"ns1:HelloResponse", id, type))
        return soap->error;
    return soap_putindependent(soap);
}

void *_ns1__HelloResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
    return soap_get__ns1__HelloResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__HelloResponse * SOAP_FMAC4 soap_get__ns1__HelloResponse(struct soap *soap, _ns1__HelloResponse *p, const char *tag, const char *type)
{
    if ((p = soap_in__ns1__HelloResponse(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 _ns1__HelloResponse * SOAP_FMAC2 soap_instantiate__ns1__HelloResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__HelloResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__HelloResponse, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(_ns1__HelloResponse);
        if (size)
            *size = sizeof(_ns1__HelloResponse);
        ((_ns1__HelloResponse*)cp->ptr)->soap = soap;
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(_ns1__HelloResponse[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(_ns1__HelloResponse);
        for (int i = 0; i < n; i++)
            ((_ns1__HelloResponse*)cp->ptr)[i].soap = soap;
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (_ns1__HelloResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__HelloResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__HelloResponse %p -> %p\n", q, p));
    *(_ns1__HelloResponse*)p = *(_ns1__HelloResponse*)q;
}

void _ns1__Hello::soap_default(struct soap *soap)
{
    this->soap = soap;
    this->_ns1__Hello::client = NULL;
    this->_ns1__Hello::app = NULL;
    this->_ns1__Hello::mainModule = NULL;
    /* transient soap skipped */
}

void _ns1__Hello::soap_serialize(struct soap *soap) const
{
    (void)soap; /* appease -Wall -Werror */
    soap_serialize_PointerTons1__ClientLib(soap, &this->_ns1__Hello::client);
    soap_serialize_PointerTons1__Application(soap, &this->_ns1__Hello::app);
    soap_serialize_PointerTostd__wstring(soap, &this->_ns1__Hello::mainModule);
    /* transient soap skipped */
}

int _ns1__Hello::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
    return soap_out__ns1__Hello(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Hello(struct soap *soap, const char *tag, int id, const _ns1__Hello *a, const char *type)
{
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Hello), type))
        return soap->error;
    if (soap_out_PointerTons1__ClientLib(soap, "ns1:client", -1, &(a->_ns1__Hello::client), ""))
        return soap->error;
    if (soap_out_PointerTons1__Application(soap, "ns1:app", -1, &(a->_ns1__Hello::app), ""))
        return soap->error;
    if (soap_out_PointerTostd__wstring(soap, "ns1:mainModule", -1, &(a->_ns1__Hello::mainModule), ""))
        return soap->error;
    /* transient soap skipped */
    return soap_element_end_out(soap, tag);
}

void *_ns1__Hello::soap_in(struct soap *soap, const char *tag, const char *type)
{   return soap_in__ns1__Hello(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Hello * SOAP_FMAC4 soap_in__ns1__Hello(struct soap *soap, const char *tag, _ns1__Hello *a, const char *type)
{
    (void)type; /* appease -Wall -Werror */
    if (soap_element_begin_in(soap, tag, 0, NULL))
        return NULL;
    a = (_ns1__Hello *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Hello, sizeof(_ns1__Hello), soap->type, soap->arrayType);
    if (!a)
        return NULL;
    if (soap->alloced)
    {   a->soap_default(soap);
        if (soap->clist->type != SOAP_TYPE__ns1__Hello)
        {   soap_revert(soap);
            *soap->id = '\0';
            return (_ns1__Hello *)a->soap_in(soap, tag, type);
        }
    }
    size_t soap_flag_client1 = 1;
    size_t soap_flag_app1 = 1;
    size_t soap_flag_mainModule1 = 1;
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_client1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTons1__ClientLib(soap, "ns1:client", &(a->_ns1__Hello::client), "ns1:ClientLib"))
                {   soap_flag_client1--;
                    continue;
                }
            if (soap_flag_app1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTons1__Application(soap, "ns1:app", &(a->_ns1__Hello::app), "ns1:Application"))
                {   soap_flag_app1--;
                    continue;
                }
            if (soap_flag_mainModule1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in_PointerTostd__wstring(soap, "ns1:mainModule", &(a->_ns1__Hello::mainModule), "xsd:string"))
                {   soap_flag_mainModule1--;
                    continue;
                }
            /* transient soap skipped */
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (_ns1__Hello *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Hello, 0, sizeof(_ns1__Hello), 0, soap_copy__ns1__Hello);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

int _ns1__Hello::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
    register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__Hello);
    if (this->soap_out(soap, tag?tag:"ns1:Hello", id, type))
        return soap->error;
    return soap_putindependent(soap);
}

void *_ns1__Hello::soap_get(struct soap *soap, const char *tag, const char *type)
{
    return soap_get__ns1__Hello(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Hello * SOAP_FMAC4 soap_get__ns1__Hello(struct soap *soap, _ns1__Hello *p, const char *tag, const char *type)
{
    if ((p = soap_in__ns1__Hello(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 _ns1__Hello * SOAP_FMAC2 soap_instantiate__ns1__Hello(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Hello(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__Hello, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(_ns1__Hello);
        if (size)
            *size = sizeof(_ns1__Hello);
        ((_ns1__Hello*)cp->ptr)->soap = soap;
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(_ns1__Hello[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(_ns1__Hello);
        for (int i = 0; i < n; i++)
            ((_ns1__Hello*)cp->ptr)[i].soap = soap;
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (_ns1__Hello*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__Hello(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__Hello %p -> %p\n", q, p));
    *(_ns1__Hello*)p = *(_ns1__Hello*)q;
}

void ns1__Solution::soap_default(struct soap *soap)
{
    this->soap = soap;
    soap_default_bool(soap, &this->ns1__Solution::askConfirmation);
    soap_default_ns1__SolutionType(soap, &this->ns1__Solution::type);
    this->ns1__Solution::url = NULL;
    this->ns1__Solution::exe = NULL;
    /* transient soap skipped */
}

void ns1__Solution::soap_serialize(struct soap *soap) const
{
    (void)soap; /* appease -Wall -Werror */
    soap_serialize_PointerTostd__wstring(soap, &this->ns1__Solution::url);
    soap_serialize_PointerTo_xop__Include(soap, &this->ns1__Solution::exe);
    /* transient soap skipped */
}

int ns1__Solution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
    return soap_out_ns1__Solution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Solution(struct soap *soap, const char *tag, int id, const ns1__Solution *a, const char *type)
{
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Solution), type))
        return soap->error;
    if (soap_out_bool(soap, "ns1:askConfirmation", -1, &(a->ns1__Solution::askConfirmation), ""))
        return soap->error;
    if (soap_out_ns1__SolutionType(soap, "ns1:type", -1, &(a->ns1__Solution::type), ""))
        return soap->error;
    if (soap_out_PointerTostd__wstring(soap, "ns1:url", -1, &(a->ns1__Solution::url), ""))
        return soap->error;
    if (soap_out_PointerTo_xop__Include(soap, "ns1:exe", -1, &(a->ns1__Solution::exe), ""))
        return soap->error;
    /* transient soap skipped */
    return soap_element_end_out(soap, tag);
}

void *ns1__Solution::soap_in(struct soap *soap, const char *tag, const char *type)
{   return soap_in_ns1__Solution(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Solution * SOAP_FMAC4 soap_in_ns1__Solution(struct soap *soap, const char *tag, ns1__Solution *a, const char *type)
{
    (void)type; /* appease -Wall -Werror */
    if (soap_element_begin_in(soap, tag, 0, NULL))
        return NULL;
    a = (ns1__Solution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Solution, sizeof(ns1__Solution), soap->type, soap->arrayType);
    if (!a)
        return NULL;
    if (soap->alloced)
    {   a->soap_default(soap);
        if (soap->clist->type != SOAP_TYPE_ns1__Solution)
        {   soap_revert(soap);
            *soap->id = '\0';
            return (ns1__Solution *)a->soap_in(soap, tag, type);
        }
    }
    size_t soap_flag_askConfirmation1 = 1;
    size_t soap_flag_type1 = 1;
    size_t soap_flag_url1 = 1;
    size_t soap_flag_exe1 = 1;
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_askConfirmation1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_bool(soap, "ns1:askConfirmation", &(a->ns1__Solution::askConfirmation), "xsd:boolean"))
                {   soap_flag_askConfirmation1--;
                    continue;
                }
            if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_ns1__SolutionType(soap, "ns1:type", &(a->ns1__Solution::type), "ns1:SolutionType"))
                {   soap_flag_type1--;
                    continue;
                }
            if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in_PointerTostd__wstring(soap, "ns1:url", &(a->ns1__Solution::url), "xsd:string"))
                {   soap_flag_url1--;
                    continue;
                }
            if (soap_flag_exe1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTo_xop__Include(soap, "ns1:exe", &(a->ns1__Solution::exe), ""))
                {   soap_flag_exe1--;
                    continue;
                }
            /* transient soap skipped */
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (ns1__Solution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Solution, 0, sizeof(ns1__Solution), 0, soap_copy_ns1__Solution);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_askConfirmation1 > 0 || soap_flag_type1 > 0))
    {   soap->error = SOAP_OCCURS;
        return NULL;
    }
    return a;
}

int ns1__Solution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
    register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Solution);
    if (this->soap_out(soap, tag?tag:"ns1:Solution", id, type))
        return soap->error;
    return soap_putindependent(soap);
}

void *ns1__Solution::soap_get(struct soap *soap, const char *tag, const char *type)
{
    return soap_get_ns1__Solution(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Solution * SOAP_FMAC4 soap_get_ns1__Solution(struct soap *soap, ns1__Solution *p, const char *tag, const char *type)
{
    if ((p = soap_in_ns1__Solution(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 ns1__Solution * SOAP_FMAC2 soap_instantiate_ns1__Solution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Solution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Solution, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(ns1__Solution);
        if (size)
            *size = sizeof(ns1__Solution);
        ((ns1__Solution*)cp->ptr)->soap = soap;
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(ns1__Solution[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(ns1__Solution);
        for (int i = 0; i < n; i++)
            ((ns1__Solution*)cp->ptr)[i].soap = soap;
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (ns1__Solution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Solution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Solution %p -> %p\n", q, p));
    *(ns1__Solution*)p = *(ns1__Solution*)q;
}

void ns1__Response::soap_default(struct soap *soap)
{
    this->soap = soap;
    soap_default_ns1__ResponseType(soap, &this->ns1__Response::type);
    this->ns1__Response::error = NULL;
    this->ns1__Response::solution = NULL;
    this->ns1__Response::clientID = NULL;
    soap_default_int(soap, &this->ns1__Response::problemID);
    soap_default_int(soap, &this->ns1__Response::dumpGroupID);
    soap_default_int(soap, &this->ns1__Response::dumpID);
    this->ns1__Response::urlToProblem = NULL;
    soap_default_ns1__AdditionalInfoType(soap, &this->ns1__Response::infoType);
    this->ns1__Response::infoModule = NULL;
    this->ns1__Response::infoModuleCfg = NULL;
    /* transient soap skipped */
}

void ns1__Response::soap_serialize(struct soap *soap) const
{
    (void)soap; /* appease -Wall -Werror */
    soap_serialize_PointerTostd__wstring(soap, &this->ns1__Response::error);
    soap_serialize_PointerTons1__Solution(soap, &this->ns1__Response::solution);
    soap_serialize_PointerTostd__wstring(soap, &this->ns1__Response::clientID);
    soap_serialize_PointerTostd__wstring(soap, &this->ns1__Response::urlToProblem);
    soap_serialize_PointerTo_xop__Include(soap, &this->ns1__Response::infoModule);
    soap_serialize_PointerTostd__wstring(soap, &this->ns1__Response::infoModuleCfg);
    /* transient soap skipped */
}

int ns1__Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
    return soap_out_ns1__Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Response(struct soap *soap, const char *tag, int id, const ns1__Response *a, const char *type)
{
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Response), type))
        return soap->error;
    if (soap_out_ns1__ResponseType(soap, "ns1:type", -1, &(a->ns1__Response::type), ""))
        return soap->error;
    if (soap_out_PointerTostd__wstring(soap, "ns1:error", -1, &(a->ns1__Response::error), ""))
        return soap->error;
    if (soap_out_PointerTons1__Solution(soap, "ns1:solution", -1, &(a->ns1__Response::solution), ""))
        return soap->error;
    if (soap_out_PointerTostd__wstring(soap, "ns1:clientID", -1, &(a->ns1__Response::clientID), ""))
        return soap->error;
    if (soap_out_int(soap, "ns1:problemID", -1, &(a->ns1__Response::problemID), ""))
        return soap->error;
    if (soap_out_int(soap, "ns1:dumpGroupID", -1, &(a->ns1__Response::dumpGroupID), ""))
        return soap->error;
    if (soap_out_int(soap, "ns1:dumpID", -1, &(a->ns1__Response::dumpID), ""))
        return soap->error;
    if (soap_out_PointerTostd__wstring(soap, "ns1:urlToProblem", -1, &(a->ns1__Response::urlToProblem), ""))
        return soap->error;
    if (soap_out_ns1__AdditionalInfoType(soap, "ns1:infoType", -1, &(a->ns1__Response::infoType), ""))
        return soap->error;
    if (soap_out_PointerTo_xop__Include(soap, "ns1:infoModule", -1, &(a->ns1__Response::infoModule), ""))
        return soap->error;
    if (soap_out_PointerTostd__wstring(soap, "ns1:infoModuleCfg", -1, &(a->ns1__Response::infoModuleCfg), ""))
        return soap->error;
    /* transient soap skipped */
    return soap_element_end_out(soap, tag);
}

void *ns1__Response::soap_in(struct soap *soap, const char *tag, const char *type)
{   return soap_in_ns1__Response(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Response * SOAP_FMAC4 soap_in_ns1__Response(struct soap *soap, const char *tag, ns1__Response *a, const char *type)
{
    (void)type; /* appease -Wall -Werror */
    if (soap_element_begin_in(soap, tag, 0, NULL))
        return NULL;
    a = (ns1__Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Response, sizeof(ns1__Response), soap->type, soap->arrayType);
    if (!a)
        return NULL;
    if (soap->alloced)
    {   a->soap_default(soap);
        if (soap->clist->type != SOAP_TYPE_ns1__Response)
        {   soap_revert(soap);
            *soap->id = '\0';
            return (ns1__Response *)a->soap_in(soap, tag, type);
        }
    }
    size_t soap_flag_type1 = 1;
    size_t soap_flag_error1 = 1;
    size_t soap_flag_solution1 = 1;
    size_t soap_flag_clientID1 = 1;
    size_t soap_flag_problemID1 = 1;
    size_t soap_flag_dumpGroupID1 = 1;
    size_t soap_flag_dumpID1 = 1;
    size_t soap_flag_urlToProblem1 = 1;
    size_t soap_flag_infoType1 = 1;
    size_t soap_flag_infoModule1 = 1;
    size_t soap_flag_infoModuleCfg1 = 1;
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_ns1__ResponseType(soap, "ns1:type", &(a->ns1__Response::type), "ns1:ResponseType"))
                {   soap_flag_type1--;
                    continue;
                }
            if (soap_flag_error1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in_PointerTostd__wstring(soap, "ns1:error", &(a->ns1__Response::error), "xsd:string"))
                {   soap_flag_error1--;
                    continue;
                }
            if (soap_flag_solution1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTons1__Solution(soap, "ns1:solution", &(a->ns1__Response::solution), "ns1:Solution"))
                {   soap_flag_solution1--;
                    continue;
                }
            if (soap_flag_clientID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in_PointerTostd__wstring(soap, "ns1:clientID", &(a->ns1__Response::clientID), "xsd:string"))
                {   soap_flag_clientID1--;
                    continue;
                }
            if (soap_flag_problemID1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_int(soap, "ns1:problemID", &(a->ns1__Response::problemID), "xsd:int"))
                {   soap_flag_problemID1--;
                    continue;
                }
            if (soap_flag_dumpGroupID1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_int(soap, "ns1:dumpGroupID", &(a->ns1__Response::dumpGroupID), "xsd:int"))
                {   soap_flag_dumpGroupID1--;
                    continue;
                }
            if (soap_flag_dumpID1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_int(soap, "ns1:dumpID", &(a->ns1__Response::dumpID), "xsd:int"))
                {   soap_flag_dumpID1--;
                    continue;
                }
            if (soap_flag_urlToProblem1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in_PointerTostd__wstring(soap, "ns1:urlToProblem", &(a->ns1__Response::urlToProblem), "xsd:string"))
                {   soap_flag_urlToProblem1--;
                    continue;
                }
            if (soap_flag_infoType1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_ns1__AdditionalInfoType(soap, "ns1:infoType", &(a->ns1__Response::infoType), "ns1:AdditionalInfoType"))
                {   soap_flag_infoType1--;
                    continue;
                }
            if (soap_flag_infoModule1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTo_xop__Include(soap, "ns1:infoModule", &(a->ns1__Response::infoModule), ""))
                {   soap_flag_infoModule1--;
                    continue;
                }
            if (soap_flag_infoModuleCfg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in_PointerTostd__wstring(soap, "ns1:infoModuleCfg", &(a->ns1__Response::infoModuleCfg), "xsd:string"))
                {   soap_flag_infoModuleCfg1--;
                    continue;
                }
            /* transient soap skipped */
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (ns1__Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Response, 0, sizeof(ns1__Response), 0, soap_copy_ns1__Response);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0 || soap_flag_problemID1 > 0 || soap_flag_dumpGroupID1 > 0 || soap_flag_dumpID1 > 0 || soap_flag_infoType1 > 0))
    {   soap->error = SOAP_OCCURS;
        return NULL;
    }
    return a;
}

int ns1__Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
    register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Response);
    if (this->soap_out(soap, tag?tag:"ns1:Response", id, type))
        return soap->error;
    return soap_putindependent(soap);
}

void *ns1__Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
    return soap_get_ns1__Response(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Response * SOAP_FMAC4 soap_get_ns1__Response(struct soap *soap, ns1__Response *p, const char *tag, const char *type)
{
    if ((p = soap_in_ns1__Response(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 ns1__Response * SOAP_FMAC2 soap_instantiate_ns1__Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Response, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(ns1__Response);
        if (size)
            *size = sizeof(ns1__Response);
        ((ns1__Response*)cp->ptr)->soap = soap;
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(ns1__Response[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(ns1__Response);
        for (int i = 0; i < n; i++)
            ((ns1__Response*)cp->ptr)[i].soap = soap;
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (ns1__Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Response %p -> %p\n", q, p));
    *(ns1__Response*)p = *(ns1__Response*)q;
}

void ns1__Application::soap_default(struct soap *soap)
{
    this->soap = soap;
    soap_default_ns2__guid(soap, &this->ns1__Application::applicationGUID);
    soap_default_unsignedShort(soap, &this->ns1__Application::v1);
    soap_default_unsignedShort(soap, &this->ns1__Application::v2);
    soap_default_unsignedShort(soap, &this->ns1__Application::v3);
    soap_default_unsignedShort(soap, &this->ns1__Application::v4);
    soap_default_unsignedShort(soap, &this->ns1__Application::hotfix);
    /* transient soap skipped */
}

void ns1__Application::soap_serialize(struct soap *soap) const
{
    (void)soap; /* appease -Wall -Werror */
    soap_serialize_ns2__guid(soap, &this->ns1__Application::applicationGUID);
    /* transient soap skipped */
}

int ns1__Application::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
    return soap_out_ns1__Application(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Application(struct soap *soap, const char *tag, int id, const ns1__Application *a, const char *type)
{
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Application), type))
        return soap->error;
    if (soap_out_ns2__guid(soap, "ns1:applicationGUID", -1, &(a->ns1__Application::applicationGUID), ""))
        return soap->error;
    if (soap_out_unsignedShort(soap, "ns1:v1", -1, &(a->ns1__Application::v1), ""))
        return soap->error;
    if (soap_out_unsignedShort(soap, "ns1:v2", -1, &(a->ns1__Application::v2), ""))
        return soap->error;
    if (soap_out_unsignedShort(soap, "ns1:v3", -1, &(a->ns1__Application::v3), ""))
        return soap->error;
    if (soap_out_unsignedShort(soap, "ns1:v4", -1, &(a->ns1__Application::v4), ""))
        return soap->error;
    if (soap_out_unsignedShort(soap, "ns1:hotfix", -1, &(a->ns1__Application::hotfix), ""))
        return soap->error;
    /* transient soap skipped */
    return soap_element_end_out(soap, tag);
}

void *ns1__Application::soap_in(struct soap *soap, const char *tag, const char *type)
{   return soap_in_ns1__Application(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Application * SOAP_FMAC4 soap_in_ns1__Application(struct soap *soap, const char *tag, ns1__Application *a, const char *type)
{
    (void)type; /* appease -Wall -Werror */
    if (soap_element_begin_in(soap, tag, 0, NULL))
        return NULL;
    a = (ns1__Application *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Application, sizeof(ns1__Application), soap->type, soap->arrayType);
    if (!a)
        return NULL;
    if (soap->alloced)
    {   a->soap_default(soap);
        if (soap->clist->type != SOAP_TYPE_ns1__Application)
        {   soap_revert(soap);
            *soap->id = '\0';
            return (ns1__Application *)a->soap_in(soap, tag, type);
        }
    }
    size_t soap_flag_applicationGUID1 = 1;
    size_t soap_flag_v11 = 1;
    size_t soap_flag_v21 = 1;
    size_t soap_flag_v31 = 1;
    size_t soap_flag_v41 = 1;
    size_t soap_flag_hotfix1 = 1;
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_applicationGUID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in_ns2__guid(soap, "ns1:applicationGUID", &(a->ns1__Application::applicationGUID), "ns2:guid"))
                {   soap_flag_applicationGUID1--;
                    continue;
                }
            if (soap_flag_v11 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_unsignedShort(soap, "ns1:v1", &(a->ns1__Application::v1), "xsd:unsignedShort"))
                {   soap_flag_v11--;
                    continue;
                }
            if (soap_flag_v21 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_unsignedShort(soap, "ns1:v2", &(a->ns1__Application::v2), "xsd:unsignedShort"))
                {   soap_flag_v21--;
                    continue;
                }
            if (soap_flag_v31 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_unsignedShort(soap, "ns1:v3", &(a->ns1__Application::v3), "xsd:unsignedShort"))
                {   soap_flag_v31--;
                    continue;
                }
            if (soap_flag_v41 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_unsignedShort(soap, "ns1:v4", &(a->ns1__Application::v4), "xsd:unsignedShort"))
                {   soap_flag_v41--;
                    continue;
                }
            if (soap_flag_hotfix1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_unsignedShort(soap, "ns1:hotfix", &(a->ns1__Application::hotfix), "xsd:unsignedShort"))
                {   soap_flag_hotfix1--;
                    continue;
                }
            /* transient soap skipped */
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (ns1__Application *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Application, 0, sizeof(ns1__Application), 0, soap_copy_ns1__Application);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_applicationGUID1 > 0 || soap_flag_v11 > 0 || soap_flag_v21 > 0 || soap_flag_v31 > 0 || soap_flag_v41 > 0 || soap_flag_hotfix1 > 0))
    {   soap->error = SOAP_OCCURS;
        return NULL;
    }
    return a;
}

int ns1__Application::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
    register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Application);
    if (this->soap_out(soap, tag?tag:"ns1:Application", id, type))
        return soap->error;
    return soap_putindependent(soap);
}

void *ns1__Application::soap_get(struct soap *soap, const char *tag, const char *type)
{
    return soap_get_ns1__Application(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Application * SOAP_FMAC4 soap_get_ns1__Application(struct soap *soap, ns1__Application *p, const char *tag, const char *type)
{
    if ((p = soap_in_ns1__Application(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 ns1__Application * SOAP_FMAC2 soap_instantiate_ns1__Application(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Application(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Application, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(ns1__Application);
        if (size)
            *size = sizeof(ns1__Application);
        ((ns1__Application*)cp->ptr)->soap = soap;
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(ns1__Application[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(ns1__Application);
        for (int i = 0; i < n; i++)
            ((ns1__Application*)cp->ptr)[i].soap = soap;
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (ns1__Application*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Application(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Application %p -> %p\n", q, p));
    *(ns1__Application*)p = *(ns1__Application*)q;
}

void ns1__ClientLib::soap_default(struct soap *soap)
{
    this->soap = soap;
    soap_default_unsignedShort(soap, &this->ns1__ClientLib::v1);
    soap_default_unsignedShort(soap, &this->ns1__ClientLib::v2);
    soap_default_unsignedShort(soap, &this->ns1__ClientLib::v3);
    soap_default_unsignedShort(soap, &this->ns1__ClientLib::v4);
    soap_default_ns1__Architecture(soap, &this->ns1__ClientLib::arch);
    /* transient soap skipped */
}

void ns1__ClientLib::soap_serialize(struct soap *soap) const
{
    (void)soap; /* appease -Wall -Werror */
    /* transient soap skipped */
}

int ns1__ClientLib::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
    return soap_out_ns1__ClientLib(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ClientLib(struct soap *soap, const char *tag, int id, const ns1__ClientLib *a, const char *type)
{
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ClientLib), type))
        return soap->error;
    if (soap_out_unsignedShort(soap, "ns1:v1", -1, &(a->ns1__ClientLib::v1), ""))
        return soap->error;
    if (soap_out_unsignedShort(soap, "ns1:v2", -1, &(a->ns1__ClientLib::v2), ""))
        return soap->error;
    if (soap_out_unsignedShort(soap, "ns1:v3", -1, &(a->ns1__ClientLib::v3), ""))
        return soap->error;
    if (soap_out_unsignedShort(soap, "ns1:v4", -1, &(a->ns1__ClientLib::v4), ""))
        return soap->error;
    if (soap_out_ns1__Architecture(soap, "ns1:arch", -1, &(a->ns1__ClientLib::arch), ""))
        return soap->error;
    /* transient soap skipped */
    return soap_element_end_out(soap, tag);
}

void *ns1__ClientLib::soap_in(struct soap *soap, const char *tag, const char *type)
{   return soap_in_ns1__ClientLib(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ClientLib * SOAP_FMAC4 soap_in_ns1__ClientLib(struct soap *soap, const char *tag, ns1__ClientLib *a, const char *type)
{
    (void)type; /* appease -Wall -Werror */
    if (soap_element_begin_in(soap, tag, 0, NULL))
        return NULL;
    a = (ns1__ClientLib *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ClientLib, sizeof(ns1__ClientLib), soap->type, soap->arrayType);
    if (!a)
        return NULL;
    if (soap->alloced)
    {   a->soap_default(soap);
        if (soap->clist->type != SOAP_TYPE_ns1__ClientLib)
        {   soap_revert(soap);
            *soap->id = '\0';
            return (ns1__ClientLib *)a->soap_in(soap, tag, type);
        }
    }
    size_t soap_flag_v11 = 1;
    size_t soap_flag_v21 = 1;
    size_t soap_flag_v31 = 1;
    size_t soap_flag_v41 = 1;
    size_t soap_flag_arch1 = 1;
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_v11 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_unsignedShort(soap, "ns1:v1", &(a->ns1__ClientLib::v1), "xsd:unsignedShort"))
                {   soap_flag_v11--;
                    continue;
                }
            if (soap_flag_v21 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_unsignedShort(soap, "ns1:v2", &(a->ns1__ClientLib::v2), "xsd:unsignedShort"))
                {   soap_flag_v21--;
                    continue;
                }
            if (soap_flag_v31 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_unsignedShort(soap, "ns1:v3", &(a->ns1__ClientLib::v3), "xsd:unsignedShort"))
                {   soap_flag_v31--;
                    continue;
                }
            if (soap_flag_v41 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_unsignedShort(soap, "ns1:v4", &(a->ns1__ClientLib::v4), "xsd:unsignedShort"))
                {   soap_flag_v41--;
                    continue;
                }
            if (soap_flag_arch1 && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_ns1__Architecture(soap, "ns1:arch", &(a->ns1__ClientLib::arch), "ns1:Architecture"))
                {   soap_flag_arch1--;
                    continue;
                }
            /* transient soap skipped */
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (ns1__ClientLib *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ClientLib, 0, sizeof(ns1__ClientLib), 0, soap_copy_ns1__ClientLib);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_v11 > 0 || soap_flag_v21 > 0 || soap_flag_v31 > 0 || soap_flag_v41 > 0 || soap_flag_arch1 > 0))
    {   soap->error = SOAP_OCCURS;
        return NULL;
    }
    return a;
}

int ns1__ClientLib::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
    register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ClientLib);
    if (this->soap_out(soap, tag?tag:"ns1:ClientLib", id, type))
        return soap->error;
    return soap_putindependent(soap);
}

void *ns1__ClientLib::soap_get(struct soap *soap, const char *tag, const char *type)
{
    return soap_get_ns1__ClientLib(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ClientLib * SOAP_FMAC4 soap_get_ns1__ClientLib(struct soap *soap, ns1__ClientLib *p, const char *tag, const char *type)
{
    if ((p = soap_in_ns1__ClientLib(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 ns1__ClientLib * SOAP_FMAC2 soap_instantiate_ns1__ClientLib(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ClientLib(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ClientLib, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(ns1__ClientLib);
        if (size)
            *size = sizeof(ns1__ClientLib);
        ((ns1__ClientLib*)cp->ptr)->soap = soap;
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(ns1__ClientLib[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(ns1__ClientLib);
        for (int i = 0; i < n; i++)
            ((ns1__ClientLib*)cp->ptr)[i].soap = soap;
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (ns1__ClientLib*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ClientLib(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ClientLib %p -> %p\n", q, p));
    *(ns1__ClientLib*)p = *(ns1__ClientLib*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    soap_default__QName(soap, &a->faultcode);
    soap_default_string(soap, &a->faultstring);
    soap_default_string(soap, &a->faultactor);
    a->detail = NULL;
    a->SOAP_ENV__Code = NULL;
    a->SOAP_ENV__Reason = NULL;
    soap_default_string(soap, &a->SOAP_ENV__Node);
    soap_default_string(soap, &a->SOAP_ENV__Role);
    a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    soap_serialize__QName(soap, &a->faultcode);
    soap_serialize_string(soap, &a->faultstring);
    soap_serialize_string(soap, &a->faultactor);
    soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
    soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
    soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
    soap_serialize_string(soap, &a->SOAP_ENV__Node);
    soap_serialize_string(soap, &a->SOAP_ENV__Role);
    soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
    const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
        return soap->error;
    if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
        return soap->error;
    if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
        return soap->error;
    if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
        return soap->error;
    if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
        return soap->error;
    if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
        return soap->error;
    if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
        return soap->error;
    if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
        return soap->error;
    if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
        return soap->error;
    if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
        return soap->error;
    return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
    size_t soap_flag_faultcode = 1;
    size_t soap_flag_faultstring = 1;
    size_t soap_flag_faultactor = 1;
    size_t soap_flag_detail = 1;
    size_t soap_flag_SOAP_ENV__Code = 1;
    size_t soap_flag_SOAP_ENV__Reason = 1;
    size_t soap_flag_SOAP_ENV__Node = 1;
    size_t soap_flag_SOAP_ENV__Role = 1;
    size_t soap_flag_SOAP_ENV__Detail = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
        return NULL;
    a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    soap_default_SOAP_ENV__Fault(soap, a);
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
                {   soap_flag_faultcode--;
                    continue;
                }
            if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
                {   soap_flag_faultstring--;
                    continue;
                }
            if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
                {   soap_flag_faultactor--;
                    continue;
                }
            if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
                {   soap_flag_detail--;
                    continue;
                }
            if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
                {   soap_flag_SOAP_ENV__Code--;
                    continue;
                }
            if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
                {   soap_flag_SOAP_ENV__Reason--;
                    continue;
                }
            if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
                {   soap_flag_SOAP_ENV__Node--;
                    continue;
                }
            if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
                {   soap_flag_SOAP_ENV__Role--;
                    continue;
                }
            if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
                {   soap_flag_SOAP_ENV__Detail--;
                    continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
    if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
    if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
        if (size)
            *size = sizeof(struct SOAP_ENV__Fault);
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(struct SOAP_ENV__Fault);
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
    *(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
        return soap->error;
    if (soap->lang)
        soap_set_attr(soap, "xml:lang", soap->lang, 1);
    if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
        return soap->error;
    return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
    size_t soap_flag_SOAP_ENV__Text = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
        return NULL;
    a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    soap_default_SOAP_ENV__Reason(soap, a);
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
                {   soap_flag_SOAP_ENV__Text--;
                    continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
    if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
    if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
        if (size)
            *size = sizeof(struct SOAP_ENV__Reason);
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(struct SOAP_ENV__Reason);
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
    *(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    a->__type = 0;
    a->fault = NULL;
    a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
        return soap->error;
    if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
        return soap->error;
    soap_outliteral(soap, "-any", &a->__any, NULL);
    return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
    size_t soap_flag_fault = 1;
    size_t soap_flag___any = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
        return NULL;
    a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    soap_default_SOAP_ENV__Detail(soap, a);
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
                if ((a->fault = soap_getelement(soap, &a->__type)))
                {   soap_flag_fault = 0;
                    continue;
                }
            if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_inliteral(soap, "-any", &a->__any))
                {   soap_flag___any--;
                    continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
    if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
    if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
        if (size)
            *size = sizeof(struct SOAP_ENV__Detail);
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(struct SOAP_ENV__Detail);
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
    *(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    soap_default__QName(soap, &a->SOAP_ENV__Value);
    a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    soap_serialize__QName(soap, &a->SOAP_ENV__Value);
    soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
    const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
        return soap->error;
    if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
        return soap->error;
    if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
        return soap->error;
    return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
    size_t soap_flag_SOAP_ENV__Value = 1;
    size_t soap_flag_SOAP_ENV__Subcode = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
        return NULL;
    a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    soap_default_SOAP_ENV__Code(soap, a);
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
                if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
                {   soap_flag_SOAP_ENV__Value--;
                    continue;
                }
            if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
                {   soap_flag_SOAP_ENV__Subcode--;
                    continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
    if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
    if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
        if (size)
            *size = sizeof(struct SOAP_ENV__Code);
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(struct SOAP_ENV__Code);
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
    *(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
    if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
        return soap->error;
    return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 0, type))
        return NULL;
    a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    soap_default_SOAP_ENV__Header(soap, a);
    if (soap->body && !*soap->href)
    {
        for (;;)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap->error == SOAP_TAG_MISMATCH)
                soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
        if (soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {   a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
    if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
    if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
        if (size)
            *size = sizeof(struct SOAP_ENV__Header);
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(struct SOAP_ENV__Header);
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
    *(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__UploadSymbol(struct soap *soap, struct __ns4__UploadSymbol *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    a->ns1__UploadSymbol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__UploadSymbol(struct soap *soap, const struct __ns4__UploadSymbol *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    soap_serialize_PointerTo_ns1__UploadSymbol(soap, &a->ns1__UploadSymbol);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__UploadSymbol(struct soap *soap, const char *tag, int id, const struct __ns4__UploadSymbol *a, const char *type)
{
    if (soap_out_PointerTo_ns1__UploadSymbol(soap, "ns1:UploadSymbol", -1, &a->ns1__UploadSymbol, ""))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__UploadSymbol * SOAP_FMAC4 soap_in___ns4__UploadSymbol(struct soap *soap, const char *tag, struct __ns4__UploadSymbol *a, const char *type)
{
    size_t soap_flag_ns1__UploadSymbol = 1;
    short soap_flag;
    a = (struct __ns4__UploadSymbol *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__UploadSymbol, sizeof(struct __ns4__UploadSymbol), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    soap_default___ns4__UploadSymbol(soap, a);
        for (soap_flag = 0;; soap_flag = 1)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_ns1__UploadSymbol && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTo_ns1__UploadSymbol(soap, "ns1:UploadSymbol", &a->ns1__UploadSymbol, ""))
                {   soap_flag_ns1__UploadSymbol--;
                    continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
                if (soap_flag)
                {   soap->error = SOAP_OK;
                    break;
                }
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__UploadSymbol(struct soap *soap, const struct __ns4__UploadSymbol *a, const char *tag, const char *type)
{
    register int id = 0;
    if (soap_out___ns4__UploadSymbol(soap, tag?tag:"-ns4:UploadSymbol", id, a, type))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__UploadSymbol * SOAP_FMAC4 soap_get___ns4__UploadSymbol(struct soap *soap, struct __ns4__UploadSymbol *p, const char *tag, const char *type)
{
    if ((p = soap_in___ns4__UploadSymbol(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 struct __ns4__UploadSymbol * SOAP_FMAC2 soap_instantiate___ns4__UploadSymbol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__UploadSymbol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__UploadSymbol, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(struct __ns4__UploadSymbol);
        if (size)
            *size = sizeof(struct __ns4__UploadSymbol);
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(struct __ns4__UploadSymbol[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(struct __ns4__UploadSymbol);
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct __ns4__UploadSymbol*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__UploadSymbol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__UploadSymbol %p -> %p\n", q, p));
    *(struct __ns4__UploadSymbol*)p = *(struct __ns4__UploadSymbol*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__UploadAdditionalInfo(struct soap *soap, struct __ns4__UploadAdditionalInfo *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    a->ns1__UploadAdditionalInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__UploadAdditionalInfo(struct soap *soap, const struct __ns4__UploadAdditionalInfo *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    soap_serialize_PointerTo_ns1__UploadAdditionalInfo(soap, &a->ns1__UploadAdditionalInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__UploadAdditionalInfo(struct soap *soap, const char *tag, int id, const struct __ns4__UploadAdditionalInfo *a, const char *type)
{
    if (soap_out_PointerTo_ns1__UploadAdditionalInfo(soap, "ns1:UploadAdditionalInfo", -1, &a->ns1__UploadAdditionalInfo, ""))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__UploadAdditionalInfo * SOAP_FMAC4 soap_in___ns4__UploadAdditionalInfo(struct soap *soap, const char *tag, struct __ns4__UploadAdditionalInfo *a, const char *type)
{
    size_t soap_flag_ns1__UploadAdditionalInfo = 1;
    short soap_flag;
    a = (struct __ns4__UploadAdditionalInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__UploadAdditionalInfo, sizeof(struct __ns4__UploadAdditionalInfo), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    soap_default___ns4__UploadAdditionalInfo(soap, a);
        for (soap_flag = 0;; soap_flag = 1)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_ns1__UploadAdditionalInfo && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTo_ns1__UploadAdditionalInfo(soap, "ns1:UploadAdditionalInfo", &a->ns1__UploadAdditionalInfo, ""))
                {   soap_flag_ns1__UploadAdditionalInfo--;
                    continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
                if (soap_flag)
                {   soap->error = SOAP_OK;
                    break;
                }
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__UploadAdditionalInfo(struct soap *soap, const struct __ns4__UploadAdditionalInfo *a, const char *tag, const char *type)
{
    register int id = 0;
    if (soap_out___ns4__UploadAdditionalInfo(soap, tag?tag:"-ns4:UploadAdditionalInfo", id, a, type))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__UploadAdditionalInfo * SOAP_FMAC4 soap_get___ns4__UploadAdditionalInfo(struct soap *soap, struct __ns4__UploadAdditionalInfo *p, const char *tag, const char *type)
{
    if ((p = soap_in___ns4__UploadAdditionalInfo(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 struct __ns4__UploadAdditionalInfo * SOAP_FMAC2 soap_instantiate___ns4__UploadAdditionalInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__UploadAdditionalInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__UploadAdditionalInfo, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(struct __ns4__UploadAdditionalInfo);
        if (size)
            *size = sizeof(struct __ns4__UploadAdditionalInfo);
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(struct __ns4__UploadAdditionalInfo[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(struct __ns4__UploadAdditionalInfo);
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct __ns4__UploadAdditionalInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__UploadAdditionalInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__UploadAdditionalInfo %p -> %p\n", q, p));
    *(struct __ns4__UploadAdditionalInfo*)p = *(struct __ns4__UploadAdditionalInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__UploadMiniDump(struct soap *soap, struct __ns4__UploadMiniDump *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    a->ns1__UploadMiniDump = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__UploadMiniDump(struct soap *soap, const struct __ns4__UploadMiniDump *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    soap_serialize_PointerTo_ns1__UploadMiniDump(soap, &a->ns1__UploadMiniDump);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__UploadMiniDump(struct soap *soap, const char *tag, int id, const struct __ns4__UploadMiniDump *a, const char *type)
{
    if (soap_out_PointerTo_ns1__UploadMiniDump(soap, "ns1:UploadMiniDump", -1, &a->ns1__UploadMiniDump, ""))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__UploadMiniDump * SOAP_FMAC4 soap_in___ns4__UploadMiniDump(struct soap *soap, const char *tag, struct __ns4__UploadMiniDump *a, const char *type)
{
    size_t soap_flag_ns1__UploadMiniDump = 1;
    short soap_flag;
    a = (struct __ns4__UploadMiniDump *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__UploadMiniDump, sizeof(struct __ns4__UploadMiniDump), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    soap_default___ns4__UploadMiniDump(soap, a);
        for (soap_flag = 0;; soap_flag = 1)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_ns1__UploadMiniDump && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTo_ns1__UploadMiniDump(soap, "ns1:UploadMiniDump", &a->ns1__UploadMiniDump, ""))
                {   soap_flag_ns1__UploadMiniDump--;
                    continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
                if (soap_flag)
                {   soap->error = SOAP_OK;
                    break;
                }
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__UploadMiniDump(struct soap *soap, const struct __ns4__UploadMiniDump *a, const char *tag, const char *type)
{
    register int id = 0;
    if (soap_out___ns4__UploadMiniDump(soap, tag?tag:"-ns4:UploadMiniDump", id, a, type))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__UploadMiniDump * SOAP_FMAC4 soap_get___ns4__UploadMiniDump(struct soap *soap, struct __ns4__UploadMiniDump *p, const char *tag, const char *type)
{
    if ((p = soap_in___ns4__UploadMiniDump(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 struct __ns4__UploadMiniDump * SOAP_FMAC2 soap_instantiate___ns4__UploadMiniDump(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__UploadMiniDump(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__UploadMiniDump, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(struct __ns4__UploadMiniDump);
        if (size)
            *size = sizeof(struct __ns4__UploadMiniDump);
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(struct __ns4__UploadMiniDump[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(struct __ns4__UploadMiniDump);
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct __ns4__UploadMiniDump*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__UploadMiniDump(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__UploadMiniDump %p -> %p\n", q, p));
    *(struct __ns4__UploadMiniDump*)p = *(struct __ns4__UploadMiniDump*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__Hello(struct soap *soap, struct __ns4__Hello *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    a->ns1__Hello = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__Hello(struct soap *soap, const struct __ns4__Hello *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    soap_serialize_PointerTo_ns1__Hello(soap, &a->ns1__Hello);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__Hello(struct soap *soap, const char *tag, int id, const struct __ns4__Hello *a, const char *type)
{
    if (soap_out_PointerTo_ns1__Hello(soap, "ns1:Hello", -1, &a->ns1__Hello, ""))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__Hello * SOAP_FMAC4 soap_in___ns4__Hello(struct soap *soap, const char *tag, struct __ns4__Hello *a, const char *type)
{
    size_t soap_flag_ns1__Hello = 1;
    short soap_flag;
    a = (struct __ns4__Hello *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__Hello, sizeof(struct __ns4__Hello), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    soap_default___ns4__Hello(soap, a);
        for (soap_flag = 0;; soap_flag = 1)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_ns1__Hello && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTo_ns1__Hello(soap, "ns1:Hello", &a->ns1__Hello, ""))
                {   soap_flag_ns1__Hello--;
                    continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
                if (soap_flag)
                {   soap->error = SOAP_OK;
                    break;
                }
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__Hello(struct soap *soap, const struct __ns4__Hello *a, const char *tag, const char *type)
{
    register int id = 0;
    if (soap_out___ns4__Hello(soap, tag?tag:"-ns4:Hello", id, a, type))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__Hello * SOAP_FMAC4 soap_get___ns4__Hello(struct soap *soap, struct __ns4__Hello *p, const char *tag, const char *type)
{
    if ((p = soap_in___ns4__Hello(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 struct __ns4__Hello * SOAP_FMAC2 soap_instantiate___ns4__Hello(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__Hello(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__Hello, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(struct __ns4__Hello);
        if (size)
            *size = sizeof(struct __ns4__Hello);
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(struct __ns4__Hello[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(struct __ns4__Hello);
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct __ns4__Hello*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__Hello(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__Hello %p -> %p\n", q, p));
    *(struct __ns4__Hello*)p = *(struct __ns4__Hello*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__UploadSymbol(struct soap *soap, struct __ns3__UploadSymbol *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    a->ns1__UploadSymbol = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__UploadSymbol(struct soap *soap, const struct __ns3__UploadSymbol *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    soap_serialize_PointerTo_ns1__UploadSymbol(soap, &a->ns1__UploadSymbol);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__UploadSymbol(struct soap *soap, const char *tag, int id, const struct __ns3__UploadSymbol *a, const char *type)
{
    if (soap_out_PointerTo_ns1__UploadSymbol(soap, "ns1:UploadSymbol", -1, &a->ns1__UploadSymbol, ""))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__UploadSymbol * SOAP_FMAC4 soap_in___ns3__UploadSymbol(struct soap *soap, const char *tag, struct __ns3__UploadSymbol *a, const char *type)
{
    size_t soap_flag_ns1__UploadSymbol = 1;
    short soap_flag;
    a = (struct __ns3__UploadSymbol *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__UploadSymbol, sizeof(struct __ns3__UploadSymbol), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    soap_default___ns3__UploadSymbol(soap, a);
        for (soap_flag = 0;; soap_flag = 1)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_ns1__UploadSymbol && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTo_ns1__UploadSymbol(soap, "ns1:UploadSymbol", &a->ns1__UploadSymbol, ""))
                {   soap_flag_ns1__UploadSymbol--;
                    continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
                if (soap_flag)
                {   soap->error = SOAP_OK;
                    break;
                }
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__UploadSymbol(struct soap *soap, const struct __ns3__UploadSymbol *a, const char *tag, const char *type)
{
    register int id = 0;
    if (soap_out___ns3__UploadSymbol(soap, tag?tag:"-ns3:UploadSymbol", id, a, type))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__UploadSymbol * SOAP_FMAC4 soap_get___ns3__UploadSymbol(struct soap *soap, struct __ns3__UploadSymbol *p, const char *tag, const char *type)
{
    if ((p = soap_in___ns3__UploadSymbol(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 struct __ns3__UploadSymbol * SOAP_FMAC2 soap_instantiate___ns3__UploadSymbol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__UploadSymbol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__UploadSymbol, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(struct __ns3__UploadSymbol);
        if (size)
            *size = sizeof(struct __ns3__UploadSymbol);
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(struct __ns3__UploadSymbol[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(struct __ns3__UploadSymbol);
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct __ns3__UploadSymbol*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__UploadSymbol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__UploadSymbol %p -> %p\n", q, p));
    *(struct __ns3__UploadSymbol*)p = *(struct __ns3__UploadSymbol*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__UploadAdditionalInfo(struct soap *soap, struct __ns3__UploadAdditionalInfo *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    a->ns1__UploadAdditionalInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__UploadAdditionalInfo(struct soap *soap, const struct __ns3__UploadAdditionalInfo *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    soap_serialize_PointerTo_ns1__UploadAdditionalInfo(soap, &a->ns1__UploadAdditionalInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__UploadAdditionalInfo(struct soap *soap, const char *tag, int id, const struct __ns3__UploadAdditionalInfo *a, const char *type)
{
    if (soap_out_PointerTo_ns1__UploadAdditionalInfo(soap, "ns1:UploadAdditionalInfo", -1, &a->ns1__UploadAdditionalInfo, ""))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__UploadAdditionalInfo * SOAP_FMAC4 soap_in___ns3__UploadAdditionalInfo(struct soap *soap, const char *tag, struct __ns3__UploadAdditionalInfo *a, const char *type)
{
    size_t soap_flag_ns1__UploadAdditionalInfo = 1;
    short soap_flag;
    a = (struct __ns3__UploadAdditionalInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__UploadAdditionalInfo, sizeof(struct __ns3__UploadAdditionalInfo), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    soap_default___ns3__UploadAdditionalInfo(soap, a);
        for (soap_flag = 0;; soap_flag = 1)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_ns1__UploadAdditionalInfo && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTo_ns1__UploadAdditionalInfo(soap, "ns1:UploadAdditionalInfo", &a->ns1__UploadAdditionalInfo, ""))
                {   soap_flag_ns1__UploadAdditionalInfo--;
                    continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
                if (soap_flag)
                {   soap->error = SOAP_OK;
                    break;
                }
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__UploadAdditionalInfo(struct soap *soap, const struct __ns3__UploadAdditionalInfo *a, const char *tag, const char *type)
{
    register int id = 0;
    if (soap_out___ns3__UploadAdditionalInfo(soap, tag?tag:"-ns3:UploadAdditionalInfo", id, a, type))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__UploadAdditionalInfo * SOAP_FMAC4 soap_get___ns3__UploadAdditionalInfo(struct soap *soap, struct __ns3__UploadAdditionalInfo *p, const char *tag, const char *type)
{
    if ((p = soap_in___ns3__UploadAdditionalInfo(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 struct __ns3__UploadAdditionalInfo * SOAP_FMAC2 soap_instantiate___ns3__UploadAdditionalInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__UploadAdditionalInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__UploadAdditionalInfo, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(struct __ns3__UploadAdditionalInfo);
        if (size)
            *size = sizeof(struct __ns3__UploadAdditionalInfo);
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(struct __ns3__UploadAdditionalInfo[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(struct __ns3__UploadAdditionalInfo);
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct __ns3__UploadAdditionalInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__UploadAdditionalInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__UploadAdditionalInfo %p -> %p\n", q, p));
    *(struct __ns3__UploadAdditionalInfo*)p = *(struct __ns3__UploadAdditionalInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__UploadMiniDump(struct soap *soap, struct __ns3__UploadMiniDump *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    a->ns1__UploadMiniDump = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__UploadMiniDump(struct soap *soap, const struct __ns3__UploadMiniDump *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    soap_serialize_PointerTo_ns1__UploadMiniDump(soap, &a->ns1__UploadMiniDump);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__UploadMiniDump(struct soap *soap, const char *tag, int id, const struct __ns3__UploadMiniDump *a, const char *type)
{
    if (soap_out_PointerTo_ns1__UploadMiniDump(soap, "ns1:UploadMiniDump", -1, &a->ns1__UploadMiniDump, ""))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__UploadMiniDump * SOAP_FMAC4 soap_in___ns3__UploadMiniDump(struct soap *soap, const char *tag, struct __ns3__UploadMiniDump *a, const char *type)
{
    size_t soap_flag_ns1__UploadMiniDump = 1;
    short soap_flag;
    a = (struct __ns3__UploadMiniDump *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__UploadMiniDump, sizeof(struct __ns3__UploadMiniDump), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    soap_default___ns3__UploadMiniDump(soap, a);
        for (soap_flag = 0;; soap_flag = 1)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_ns1__UploadMiniDump && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTo_ns1__UploadMiniDump(soap, "ns1:UploadMiniDump", &a->ns1__UploadMiniDump, ""))
                {   soap_flag_ns1__UploadMiniDump--;
                    continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
                if (soap_flag)
                {   soap->error = SOAP_OK;
                    break;
                }
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__UploadMiniDump(struct soap *soap, const struct __ns3__UploadMiniDump *a, const char *tag, const char *type)
{
    register int id = 0;
    if (soap_out___ns3__UploadMiniDump(soap, tag?tag:"-ns3:UploadMiniDump", id, a, type))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__UploadMiniDump * SOAP_FMAC4 soap_get___ns3__UploadMiniDump(struct soap *soap, struct __ns3__UploadMiniDump *p, const char *tag, const char *type)
{
    if ((p = soap_in___ns3__UploadMiniDump(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 struct __ns3__UploadMiniDump * SOAP_FMAC2 soap_instantiate___ns3__UploadMiniDump(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__UploadMiniDump(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__UploadMiniDump, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(struct __ns3__UploadMiniDump);
        if (size)
            *size = sizeof(struct __ns3__UploadMiniDump);
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(struct __ns3__UploadMiniDump[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(struct __ns3__UploadMiniDump);
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct __ns3__UploadMiniDump*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__UploadMiniDump(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__UploadMiniDump %p -> %p\n", q, p));
    *(struct __ns3__UploadMiniDump*)p = *(struct __ns3__UploadMiniDump*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__Hello(struct soap *soap, struct __ns3__Hello *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    a->ns1__Hello = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__Hello(struct soap *soap, const struct __ns3__Hello *a)
{
    (void)soap; (void)a; /* appease -Wall -Werror */
    soap_serialize_PointerTo_ns1__Hello(soap, &a->ns1__Hello);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__Hello(struct soap *soap, const char *tag, int id, const struct __ns3__Hello *a, const char *type)
{
    if (soap_out_PointerTo_ns1__Hello(soap, "ns1:Hello", -1, &a->ns1__Hello, ""))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__Hello * SOAP_FMAC4 soap_in___ns3__Hello(struct soap *soap, const char *tag, struct __ns3__Hello *a, const char *type)
{
    size_t soap_flag_ns1__Hello = 1;
    short soap_flag;
    a = (struct __ns3__Hello *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__Hello, sizeof(struct __ns3__Hello), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    soap_default___ns3__Hello(soap, a);
        for (soap_flag = 0;; soap_flag = 1)
        {   soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_ns1__Hello && soap->error == SOAP_TAG_MISMATCH)
                if (soap_in_PointerTo_ns1__Hello(soap, "ns1:Hello", &a->ns1__Hello, ""))
                {   soap_flag_ns1__Hello--;
                    continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
                if (soap_flag)
                {   soap->error = SOAP_OK;
                    break;
                }
            if (soap->error == SOAP_NO_TAG)
                break;
            if (soap->error)
                return NULL;
        }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__Hello(struct soap *soap, const struct __ns3__Hello *a, const char *tag, const char *type)
{
    register int id = 0;
    if (soap_out___ns3__Hello(soap, tag?tag:"-ns3:Hello", id, a, type))
        return soap->error;
    return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__Hello * SOAP_FMAC4 soap_get___ns3__Hello(struct soap *soap, struct __ns3__Hello *p, const char *tag, const char *type)
{
    if ((p = soap_in___ns3__Hello(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 struct __ns3__Hello * SOAP_FMAC2 soap_instantiate___ns3__Hello(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns3__Hello(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns3__Hello, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(struct __ns3__Hello);
        if (size)
            *size = sizeof(struct __ns3__Hello);
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(struct __ns3__Hello[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(struct __ns3__Hello);
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct __ns3__Hello*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns3__Hello(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns3__Hello %p -> %p\n", q, p));
    *(struct __ns3__Hello*)p = *(struct __ns3__Hello*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xop__Include(struct soap *soap, struct _xop__Include *a)
{
    (void)soap; /* appease -Wall -Werror */
    a->__size = 0;
    a->__ptr = NULL;
    a->id = NULL;
    a->type = NULL;
    a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xop__Include(struct soap *soap, struct _xop__Include const*a)
{
    if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE__xop__Include))
        if (a->id || a->type)
            soap->mode |= SOAP_ENC_DIME;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xop__Include(struct soap *soap, const char *tag, int id, const struct _xop__Include *a, const char *type)
{
#ifndef WITH_LEANER
    id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE__xop__Include);
#else
    id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE__xop__Include);
#endif
    if (id < 0)
        return soap->error;
    if (soap_element_begin_out(soap, tag, id, type))
        return soap->error;
    if (soap_putbase64(soap, a->__ptr, a->__size))
        return soap->error;
    return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_in__xop__Include(struct soap *soap, const char *tag, struct _xop__Include *a, const char *type)
{
    (void)type; /* appease -Wall -Werror */
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
    {   soap->error = SOAP_TYPE;
        return NULL;
    }
    a = (struct _xop__Include *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), 0, NULL, NULL, NULL);
    if (!a)
        return NULL;
    soap_default__xop__Include(soap, a);
    if (soap->body && !*soap->href)
    {
        a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
        if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
            return NULL;
#endif
        if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
            return NULL;
    }
    else
    {
#ifndef WITH_LEANER
        if (*soap->href != '#')
        {   if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
                return NULL;
        }
        else
#endif
            a = (struct _xop__Include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xop__Include, 0, sizeof(struct _xop__Include), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xop__Include(struct soap *soap, const struct _xop__Include *a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE__xop__Include);
    if (soap_out__xop__Include(soap, tag?tag:"xop:Include", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_get__xop__Include(struct soap *soap, struct _xop__Include *p, const char *tag, const char *type)
{
    if ((p = soap_in__xop__Include(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC1 struct _xop__Include * SOAP_FMAC2 soap_instantiate__xop__Include(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
    (void)type; (void)arrayType; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__xop__Include(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__xop__Include, n, soap_fdelete);
    if (!cp)
        return NULL;
    if (n < 0)
    {   cp->ptr = (void*)SOAP_NEW(struct _xop__Include);
        if (size)
            *size = sizeof(struct _xop__Include);
    }
    else
    {   cp->ptr = (void*)SOAP_NEW(struct _xop__Include[n]);
        if (!cp->ptr)
        {   soap->error = SOAP_EOM;
            return NULL;
        }
        if (size)
            *size = n * sizeof(struct _xop__Include);
    }
        DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct _xop__Include*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__xop__Include(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
    (void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _xop__Include %p -> %p\n", q, p));
    *(struct _xop__Include*)p = *(struct _xop__Include*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
    if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
        soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
    if (id < 0)
        return soap->error;
    return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
            return NULL;
    }
    else
    {   a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
    if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
    if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
        soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
    if (id < 0)
        return soap->error;
    return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
            return NULL;
    }
    else
    {   a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
    if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
    if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
        soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
    if (id < 0)
        return soap->error;
    return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
            return NULL;
    }
    else
    {   a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
    if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UploadSymbolResponse(struct soap *soap, _ns1__UploadSymbolResponse *const*a)
{
    if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UploadSymbolResponse))
        (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UploadSymbolResponse(struct soap *soap, const char *tag, int id, _ns1__UploadSymbolResponse *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UploadSymbolResponse);
    if (id < 0)
        return soap->error;
    return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UploadSymbolResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UploadSymbolResponse(struct soap *soap, const char *tag, _ns1__UploadSymbolResponse **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (_ns1__UploadSymbolResponse **)soap_malloc(soap, sizeof(_ns1__UploadSymbolResponse *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = (_ns1__UploadSymbolResponse *)soap_instantiate__ns1__UploadSymbolResponse(soap, -1, soap->type, soap->arrayType, NULL)))
            return NULL;
        (*a)->soap_default(soap);
        if (!(*a)->soap_in(soap, tag, NULL))
            return NULL;
    }
    else
    {   _ns1__UploadSymbolResponse ** p = (_ns1__UploadSymbolResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UploadSymbolResponse, sizeof(_ns1__UploadSymbolResponse), 0);
        a = p;
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UploadSymbolResponse(struct soap *soap, _ns1__UploadSymbolResponse *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UploadSymbolResponse);
    if (soap_out_PointerTo_ns1__UploadSymbolResponse(soap, tag?tag:"ns1:UploadSymbolResponse", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UploadSymbolResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UploadSymbolResponse(struct soap *soap, _ns1__UploadSymbolResponse **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerTo_ns1__UploadSymbolResponse(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UploadSymbol(struct soap *soap, _ns1__UploadSymbol *const*a)
{
    if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UploadSymbol))
        (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UploadSymbol(struct soap *soap, const char *tag, int id, _ns1__UploadSymbol *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UploadSymbol);
    if (id < 0)
        return soap->error;
    return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UploadSymbol ** SOAP_FMAC4 soap_in_PointerTo_ns1__UploadSymbol(struct soap *soap, const char *tag, _ns1__UploadSymbol **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (_ns1__UploadSymbol **)soap_malloc(soap, sizeof(_ns1__UploadSymbol *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = (_ns1__UploadSymbol *)soap_instantiate__ns1__UploadSymbol(soap, -1, soap->type, soap->arrayType, NULL)))
            return NULL;
        (*a)->soap_default(soap);
        if (!(*a)->soap_in(soap, tag, NULL))
            return NULL;
    }
    else
    {   _ns1__UploadSymbol ** p = (_ns1__UploadSymbol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UploadSymbol, sizeof(_ns1__UploadSymbol), 0);
        a = p;
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UploadSymbol(struct soap *soap, _ns1__UploadSymbol *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UploadSymbol);
    if (soap_out_PointerTo_ns1__UploadSymbol(soap, tag?tag:"ns1:UploadSymbol", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UploadSymbol ** SOAP_FMAC4 soap_get_PointerTo_ns1__UploadSymbol(struct soap *soap, _ns1__UploadSymbol **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerTo_ns1__UploadSymbol(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UploadAdditionalInfoResponse(struct soap *soap, _ns1__UploadAdditionalInfoResponse *const*a)
{
    if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UploadAdditionalInfoResponse))
        (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UploadAdditionalInfoResponse(struct soap *soap, const char *tag, int id, _ns1__UploadAdditionalInfoResponse *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UploadAdditionalInfoResponse);
    if (id < 0)
        return soap->error;
    return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UploadAdditionalInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UploadAdditionalInfoResponse(struct soap *soap, const char *tag, _ns1__UploadAdditionalInfoResponse **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (_ns1__UploadAdditionalInfoResponse **)soap_malloc(soap, sizeof(_ns1__UploadAdditionalInfoResponse *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = (_ns1__UploadAdditionalInfoResponse *)soap_instantiate__ns1__UploadAdditionalInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
            return NULL;
        (*a)->soap_default(soap);
        if (!(*a)->soap_in(soap, tag, NULL))
            return NULL;
    }
    else
    {   _ns1__UploadAdditionalInfoResponse ** p = (_ns1__UploadAdditionalInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UploadAdditionalInfoResponse, sizeof(_ns1__UploadAdditionalInfoResponse), 0);
        a = p;
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UploadAdditionalInfoResponse(struct soap *soap, _ns1__UploadAdditionalInfoResponse *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UploadAdditionalInfoResponse);
    if (soap_out_PointerTo_ns1__UploadAdditionalInfoResponse(soap, tag?tag:"ns1:UploadAdditionalInfoResponse", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UploadAdditionalInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UploadAdditionalInfoResponse(struct soap *soap, _ns1__UploadAdditionalInfoResponse **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerTo_ns1__UploadAdditionalInfoResponse(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UploadAdditionalInfo(struct soap *soap, _ns1__UploadAdditionalInfo *const*a)
{
    if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UploadAdditionalInfo))
        (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UploadAdditionalInfo(struct soap *soap, const char *tag, int id, _ns1__UploadAdditionalInfo *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UploadAdditionalInfo);
    if (id < 0)
        return soap->error;
    return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UploadAdditionalInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__UploadAdditionalInfo(struct soap *soap, const char *tag, _ns1__UploadAdditionalInfo **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (_ns1__UploadAdditionalInfo **)soap_malloc(soap, sizeof(_ns1__UploadAdditionalInfo *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = (_ns1__UploadAdditionalInfo *)soap_instantiate__ns1__UploadAdditionalInfo(soap, -1, soap->type, soap->arrayType, NULL)))
            return NULL;
        (*a)->soap_default(soap);
        if (!(*a)->soap_in(soap, tag, NULL))
            return NULL;
    }
    else
    {   _ns1__UploadAdditionalInfo ** p = (_ns1__UploadAdditionalInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UploadAdditionalInfo, sizeof(_ns1__UploadAdditionalInfo), 0);
        a = p;
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UploadAdditionalInfo(struct soap *soap, _ns1__UploadAdditionalInfo *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UploadAdditionalInfo);
    if (soap_out_PointerTo_ns1__UploadAdditionalInfo(soap, tag?tag:"ns1:UploadAdditionalInfo", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UploadAdditionalInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__UploadAdditionalInfo(struct soap *soap, _ns1__UploadAdditionalInfo **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerTo_ns1__UploadAdditionalInfo(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UploadMiniDumpResponse(struct soap *soap, _ns1__UploadMiniDumpResponse *const*a)
{
    if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UploadMiniDumpResponse))
        (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UploadMiniDumpResponse(struct soap *soap, const char *tag, int id, _ns1__UploadMiniDumpResponse *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UploadMiniDumpResponse);
    if (id < 0)
        return soap->error;
    return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UploadMiniDumpResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UploadMiniDumpResponse(struct soap *soap, const char *tag, _ns1__UploadMiniDumpResponse **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (_ns1__UploadMiniDumpResponse **)soap_malloc(soap, sizeof(_ns1__UploadMiniDumpResponse *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = (_ns1__UploadMiniDumpResponse *)soap_instantiate__ns1__UploadMiniDumpResponse(soap, -1, soap->type, soap->arrayType, NULL)))
            return NULL;
        (*a)->soap_default(soap);
        if (!(*a)->soap_in(soap, tag, NULL))
            return NULL;
    }
    else
    {   _ns1__UploadMiniDumpResponse ** p = (_ns1__UploadMiniDumpResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UploadMiniDumpResponse, sizeof(_ns1__UploadMiniDumpResponse), 0);
        a = p;
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UploadMiniDumpResponse(struct soap *soap, _ns1__UploadMiniDumpResponse *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UploadMiniDumpResponse);
    if (soap_out_PointerTo_ns1__UploadMiniDumpResponse(soap, tag?tag:"ns1:UploadMiniDumpResponse", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UploadMiniDumpResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UploadMiniDumpResponse(struct soap *soap, _ns1__UploadMiniDumpResponse **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerTo_ns1__UploadMiniDumpResponse(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UploadMiniDump(struct soap *soap, _ns1__UploadMiniDump *const*a)
{
    if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UploadMiniDump))
        (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UploadMiniDump(struct soap *soap, const char *tag, int id, _ns1__UploadMiniDump *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UploadMiniDump);
    if (id < 0)
        return soap->error;
    return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UploadMiniDump ** SOAP_FMAC4 soap_in_PointerTo_ns1__UploadMiniDump(struct soap *soap, const char *tag, _ns1__UploadMiniDump **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (_ns1__UploadMiniDump **)soap_malloc(soap, sizeof(_ns1__UploadMiniDump *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = (_ns1__UploadMiniDump *)soap_instantiate__ns1__UploadMiniDump(soap, -1, soap->type, soap->arrayType, NULL)))
            return NULL;
        (*a)->soap_default(soap);
        if (!(*a)->soap_in(soap, tag, NULL))
            return NULL;
    }
    else
    {   _ns1__UploadMiniDump ** p = (_ns1__UploadMiniDump **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UploadMiniDump, sizeof(_ns1__UploadMiniDump), 0);
        a = p;
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UploadMiniDump(struct soap *soap, _ns1__UploadMiniDump *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UploadMiniDump);
    if (soap_out_PointerTo_ns1__UploadMiniDump(soap, tag?tag:"ns1:UploadMiniDump", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UploadMiniDump ** SOAP_FMAC4 soap_get_PointerTo_ns1__UploadMiniDump(struct soap *soap, _ns1__UploadMiniDump **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerTo_ns1__UploadMiniDump(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__HelloResponse(struct soap *soap, _ns1__HelloResponse *const*a)
{
    if (!soap_reference(soap, *a, SOAP_TYPE__ns1__HelloResponse))
        (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__HelloResponse(struct soap *soap, const char *tag, int id, _ns1__HelloResponse *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__HelloResponse);
    if (id < 0)
        return soap->error;
    return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__HelloResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__HelloResponse(struct soap *soap, const char *tag, _ns1__HelloResponse **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (_ns1__HelloResponse **)soap_malloc(soap, sizeof(_ns1__HelloResponse *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = (_ns1__HelloResponse *)soap_instantiate__ns1__HelloResponse(soap, -1, soap->type, soap->arrayType, NULL)))
            return NULL;
        (*a)->soap_default(soap);
        if (!(*a)->soap_in(soap, tag, NULL))
            return NULL;
    }
    else
    {   _ns1__HelloResponse ** p = (_ns1__HelloResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__HelloResponse, sizeof(_ns1__HelloResponse), 0);
        a = p;
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__HelloResponse(struct soap *soap, _ns1__HelloResponse *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__HelloResponse);
    if (soap_out_PointerTo_ns1__HelloResponse(soap, tag?tag:"ns1:HelloResponse", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__HelloResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__HelloResponse(struct soap *soap, _ns1__HelloResponse **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerTo_ns1__HelloResponse(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Hello(struct soap *soap, _ns1__Hello *const*a)
{
    if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Hello))
        (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Hello(struct soap *soap, const char *tag, int id, _ns1__Hello *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Hello);
    if (id < 0)
        return soap->error;
    return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Hello ** SOAP_FMAC4 soap_in_PointerTo_ns1__Hello(struct soap *soap, const char *tag, _ns1__Hello **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (_ns1__Hello **)soap_malloc(soap, sizeof(_ns1__Hello *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = (_ns1__Hello *)soap_instantiate__ns1__Hello(soap, -1, soap->type, soap->arrayType, NULL)))
            return NULL;
        (*a)->soap_default(soap);
        if (!(*a)->soap_in(soap, tag, NULL))
            return NULL;
    }
    else
    {   _ns1__Hello ** p = (_ns1__Hello **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Hello, sizeof(_ns1__Hello), 0);
        a = p;
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Hello(struct soap *soap, _ns1__Hello *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__Hello);
    if (soap_out_PointerTo_ns1__Hello(soap, tag?tag:"ns1:Hello", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Hello ** SOAP_FMAC4 soap_get_PointerTo_ns1__Hello(struct soap *soap, _ns1__Hello **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerTo_ns1__Hello(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Response(struct soap *soap, ns1__Response *const*a)
{
    if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Response))
        (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Response(struct soap *soap, const char *tag, int id, ns1__Response *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Response);
    if (id < 0)
        return soap->error;
    return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Response ** SOAP_FMAC4 soap_in_PointerTons1__Response(struct soap *soap, const char *tag, ns1__Response **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (ns1__Response **)soap_malloc(soap, sizeof(ns1__Response *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = (ns1__Response *)soap_instantiate_ns1__Response(soap, -1, soap->type, soap->arrayType, NULL)))
            return NULL;
        (*a)->soap_default(soap);
        if (!(*a)->soap_in(soap, tag, NULL))
            return NULL;
    }
    else
    {   ns1__Response ** p = (ns1__Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Response, sizeof(ns1__Response), 0);
        a = p;
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Response(struct soap *soap, ns1__Response *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Response);
    if (soap_out_PointerTons1__Response(soap, tag?tag:"ns1:Response", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Response ** SOAP_FMAC4 soap_get_PointerTons1__Response(struct soap *soap, ns1__Response **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerTons1__Response(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Application(struct soap *soap, ns1__Application *const*a)
{
    if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Application))
        (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Application(struct soap *soap, const char *tag, int id, ns1__Application *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Application);
    if (id < 0)
        return soap->error;
    return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Application ** SOAP_FMAC4 soap_in_PointerTons1__Application(struct soap *soap, const char *tag, ns1__Application **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (ns1__Application **)soap_malloc(soap, sizeof(ns1__Application *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = (ns1__Application *)soap_instantiate_ns1__Application(soap, -1, soap->type, soap->arrayType, NULL)))
            return NULL;
        (*a)->soap_default(soap);
        if (!(*a)->soap_in(soap, tag, NULL))
            return NULL;
    }
    else
    {   ns1__Application ** p = (ns1__Application **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Application, sizeof(ns1__Application), 0);
        a = p;
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Application(struct soap *soap, ns1__Application *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Application);
    if (soap_out_PointerTons1__Application(soap, tag?tag:"ns1:Application", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Application ** SOAP_FMAC4 soap_get_PointerTons1__Application(struct soap *soap, ns1__Application **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerTons1__Application(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ClientLib(struct soap *soap, ns1__ClientLib *const*a)
{
    if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ClientLib))
        (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ClientLib(struct soap *soap, const char *tag, int id, ns1__ClientLib *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ClientLib);
    if (id < 0)
        return soap->error;
    return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ClientLib ** SOAP_FMAC4 soap_in_PointerTons1__ClientLib(struct soap *soap, const char *tag, ns1__ClientLib **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (ns1__ClientLib **)soap_malloc(soap, sizeof(ns1__ClientLib *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = (ns1__ClientLib *)soap_instantiate_ns1__ClientLib(soap, -1, soap->type, soap->arrayType, NULL)))
            return NULL;
        (*a)->soap_default(soap);
        if (!(*a)->soap_in(soap, tag, NULL))
            return NULL;
    }
    else
    {   ns1__ClientLib ** p = (ns1__ClientLib **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ClientLib, sizeof(ns1__ClientLib), 0);
        a = p;
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ClientLib(struct soap *soap, ns1__ClientLib *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ClientLib);
    if (soap_out_PointerTons1__ClientLib(soap, tag?tag:"ns1:ClientLib", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ClientLib ** SOAP_FMAC4 soap_get_PointerTons1__ClientLib(struct soap *soap, ns1__ClientLib **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerTons1__ClientLib(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xop__Include(struct soap *soap, struct _xop__Include *const*a)
{
    if (*a)
        soap_serialize__xop__Include(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xop__Include(struct soap *soap, const char *tag, int id, struct _xop__Include *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE__xop__Include);
    if (id < 0)
        return soap->error;
    return soap_out__xop__Include(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _xop__Include ** SOAP_FMAC4 soap_in_PointerTo_xop__Include(struct soap *soap, const char *tag, struct _xop__Include **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (struct _xop__Include **)soap_malloc(soap, sizeof(struct _xop__Include *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = soap_in__xop__Include(soap, tag, *a, type)))
            return NULL;
    }
    else
    {   a = (struct _xop__Include **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), 0);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xop__Include(struct soap *soap, struct _xop__Include *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_xop__Include);
    if (soap_out_PointerTo_xop__Include(soap, tag?tag:"xop:Include", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xop__Include ** SOAP_FMAC4 soap_get_PointerTo_xop__Include(struct soap *soap, struct _xop__Include **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerTo_xop__Include(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Solution(struct soap *soap, ns1__Solution *const*a)
{
    if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Solution))
        (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Solution(struct soap *soap, const char *tag, int id, ns1__Solution *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Solution);
    if (id < 0)
        return soap->error;
    return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Solution ** SOAP_FMAC4 soap_in_PointerTons1__Solution(struct soap *soap, const char *tag, ns1__Solution **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (ns1__Solution **)soap_malloc(soap, sizeof(ns1__Solution *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = (ns1__Solution *)soap_instantiate_ns1__Solution(soap, -1, soap->type, soap->arrayType, NULL)))
            return NULL;
        (*a)->soap_default(soap);
        if (!(*a)->soap_in(soap, tag, NULL))
            return NULL;
    }
    else
    {   ns1__Solution ** p = (ns1__Solution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Solution, sizeof(ns1__Solution), 0);
        a = p;
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Solution(struct soap *soap, ns1__Solution *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Solution);
    if (soap_out_PointerTons1__Solution(soap, tag?tag:"ns1:Solution", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Solution ** SOAP_FMAC4 soap_get_PointerTons1__Solution(struct soap *soap, ns1__Solution **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerTons1__Solution(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__wstring(struct soap *soap, std::wstring *const*a)
{
    if (!soap_reference(soap, *a, SOAP_TYPE_std__wstring))
        soap_serialize_std__wstring(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__wstring(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__wstring);
    if (id < 0)
        return soap->error;
    return soap_out_std__wstring(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTostd__wstring(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = soap_in_std__wstring(soap, tag, *a, type)))
            return NULL;
    }
    else
    {   a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__wstring, sizeof(std::wstring), 0);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__wstring(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__wstring);
    if (soap_out_PointerTostd__wstring(soap, tag?tag:"string", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTostd__wstring(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerTostd__wstring(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
    soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
    id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
    if (id < 0)
        return soap->error;
    return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
    if (soap_element_begin_in(soap, tag, 1, NULL))
        return NULL;
    if (!a)
        if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
            return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
    {   soap_revert(soap);
        if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
            return NULL;
    }
    else
    {   a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
        if (soap->body && soap_element_end_in(soap, tag))
            return NULL;
    }
    return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
    if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
    if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
    return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{   char **p;
    p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
    return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
    if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
    if ((p = soap_in__QName(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
    (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
    *a = SOAP_DEFAULT_string;
#else
    *a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
    soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
    return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{   char **p;
    p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
    return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
    register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
    if (soap_out_string(soap, tag?tag:"byte", id, a, type))
        return soap->error;
    return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
    if ((p = soap_in_string(soap, tag, p, type)))
        if (soap_getindependent(soap))
            return NULL;
    return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
